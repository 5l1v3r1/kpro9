%=================
% Introduction
\chapter*{Introduction}
%=================

This chapter is a technical introduction to our project.
It gives a concise explanation of the most important terms used in the report.

The first section briefly explains \Gls{wireshark}, \glspl{dissector} and how \glspl{dissector} are used in \Gls{wireshark}.
The connection between \Gls{wireshark} and the \Gls{lua} \glspl{struct} \gls{protocol} is also explained.

The second section describes how the \Gls{lua} code works and how it is generated by our \gls{utility}.

\section*{Wireshark and dissectors}
This section gives a brief introduction to \Gls{wireshark} and \glspl{dissector}.
The first part describes what \Gls{wireshark} is and what it can be used for.
The second part explains exactly what a \gls{dissector} is, and how a \gls{dissector} can be used to extend \Gls{wireshark}.

\subsection*{Wireshark}
\Gls{wireshark} is a program used to analyze network traffic. A common usage scenario is when a person wants to troubleshoot network problems or
look at the internal workings of a network \gls{protocol}. An important feature of \Gls{wireshark} is the ability to capture and display a live stream of \glspl{packet} sent through the network. 
A user could, for example, see exactly what happens when he opens up a website. \Gls{wireshark} will then display all the messages
sent between his computer and the web server. It is also possible to filter and search on given \gls{packet} attributes, which facilitates the debugging \gls{process}.

In \autoref{fig:introshark}, you can see a view of \Gls{wireshark}.
This specific example shows a capture file with four messages, or \glspl{packet}, sent between internal \glspl{process}, in other words
it is a view of messages sent by inter-\gls{process} communication. Each of the \glspl{packet} contain one \Gls{c} \gls{struct}.
To be able to display the contents of the \Gls{c} \gls{struct}, \Gls{wireshark} has to be extended. 
This can be accomplished by writing a \gls{dissector} for the \Gls{c} \gls{struct}.

The \glspl{dissector} can be written in either \Gls{c} or \Gls{lua}, and in our \gls{utility} they are written in \Gls{lua}.
The difference between \Gls{c} and \Gls{lua} \glspl{dissector}, and the reason we used \Gls{lua} is elaborated on in the Pre Study-chapter.
Dissectors, in general, are explained more in detail below.

\begin{figure}[ht]
	\includegraphics[width=\textwidth]{./img/wireshark_example.png}
	\caption{\Gls{wireshark}\label{fig:introshark}}
\end{figure}

\subsection*{Dissectors}
In short, a \gls{dissector} is a piece of code, run on a blob of data, that can dissect the
data and display it in a readable format in \Gls{wireshark}, instead of the \gls{binary} representation.

\autoref{fig:introshark} displays four \glspl{packet}, with \gls{packet} number 1 highlighted.
The content of the \gls{packet} is a \Gls{c} \gls{struct} with two \glspl{member}, name and time, and it is displayed inside the green box.
The \Gls{c} code for the \gls{struct} is shown in \autoref{structexample}.
The \gls{dissector} takes the \Gls{c} \gls{struct}, decodes its \gls{binary} representation and makes it readable by humans.
Without a \gls{dissector}, \Gls{wireshark} would just display the \gls{struct} and \gls{struct} \glspl{member} as a \gls{binary} blob.

All the \glspl{packet} containing \Gls{c} \glspl{struct} belong to the \gls{protocol} called luastructs.
When opening a capture file in \Gls{wireshark} , this \gls{protocol} maps the id of the messages to the correct \gls{dissector},
and calls them.

\lstset{language=C,caption={Example \Gls{c} \gls{struct}},label=structexample}
\lstinputlisting[language=C]{./code/struct.h}

\section*{From \gls{struct} definition to \Gls{lua} \gls{dissector}}
This section explains how the \Gls{lua} \glspl{dissector} work, and how they can be built by our \gls{utility}.

The first part explains what happens under the hood of a \Gls{lua} \gls{dissector}, while 
the second part is a very brief explanation of how CSjark builds such \glspl{dissector}.

\subsection*{\Gls{lua} \glspl{dissector}}

\autoref{luaexample1} shows what the code for the \Gls{lua} \gls{dissector}, displayed in \gls{packet} 1 in \autoref{fig:introshark}, looks like.
The Proto variable defines a new \gls{protocol}. In this example, a \gls{dissector} for the internal\_snd \gls{struct}, called internal\_snd, is created. 
The different fields of the \gls{struct} are created as instances of ProtoField, and put in Protocol.fields.
For example, the "name" variable is a \gls{string} in \Gls{c}, and as such it is created as a ProtoField.\gls{string} with the 
name "name".

The \gls{protocol} \gls{dissector} method is the method that does the actual dissecting.
A subtree for the \gls{dissector} is created, and the description of the \gls{dissector} is appended to the information column.
All the ProtoFields are added to the subtree. Here you can see that the type, name and time fields are added to the subtree for the internal\_snd \gls{dissector}.
The buffer size allocated to the fields is the size of the \glspl{member} in \Gls{c}.

In the last line the \gls{dissector} is added to the \gls{dissector} table as a subdissector for the luastructs \gls{protocol}.
When running a capture file, where the internal\_snd \gls{struct} is being sent to another \gls{process}, it is possible to see the exact contents of the \gls{struct}, as the example screenshot of \Gls{wireshark} shows.

\lstset{language=C,caption={Example \Gls{lua} file},label=luaexample1}
\lstinputlisting[language=C]{./code/luaexample1.lua}

\subsection*{CSjark - Automated generation of \Gls{lua} \glspl{dissector}}
CSjark is a \Gls{python} \gls{utility} that can automatically generate a \Gls{lua} \gls{dissector} for 
any valid \Gls{c} \gls{header} file. It also supports user configuration from files in a specific format.
The \Gls{c} file, in addition to any suitable configuration file, is inputted into a command line interface.
The \Gls{c} file is then sent to the \Gls{c} preprocessor, where \Gls{c} directives are evaluated before the parsing.
The \gls{parser} creates an abstract syntax tree from the input.
CSjark traverses the abstract syntax tree and finds all the \gls{struct} definitions.
For every \gls{struct} that is found, a \gls{dissector} is generated and written to file.






