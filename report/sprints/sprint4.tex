%=================
\chapter{Sprint 4}
%=================
TODO

%------------------------
\section{Sprint Planning}
%------------------------
The fourth sprint will be the last iteration in this project. Testing and bugfixing will take most of the sprint work hours, because it is very important to make the utility work properly on Thales source code. Now the utility fail on most of the structs; Stig tried to generate dissectors for 580 structs, where only 4 of them succeeded. It will probably just be some small tweaks needed, to make it work for most of the structs.

We know that some of our earlier implementation do not work as intended or is incomplete. The customer has given us feedback on the fulfilled requirements, and pointed out what needs to be improved. These are important work items of this sprint backlog \ref{sp4:backlog}. In addition we got new requirements that would be nice if we implemented, some which will be convenient for the customer to have. For the optional requirements we do not have time to implement, we have agreed to write a specification on how to implement them. 

There will not be another sprint after this one, so we can not postpone any work items. Because of this, we had to make some of the new requirements from the customer optional, and also telling the customer that we will probably not be able complete all their desires. We are tyring to improve from tha last sprint, are not going to add more tasks than we can complete this sprint. This sprint we plan to use close to 350 hours, but it is still likely that we will use more and are prepared for that. It will certainly pop up new tasks and unforeseen bugs that we have to fix.

\subsection{Duration}
%-----------------------
The sprint started with the planning meeting the 2nd of November and our work started the following day. The sprint duration is 14 days, and will end the 15th of November with a review meeting. 

\subsection{Sprint Goal}
%-----------------------
The goal of this sprint will be focusing on fixing and implement function that the customer will need to use the utility on their source code. The most important thing to focus on in beginning of the sprint will be to implement support for \#pragma directives and support for including header-files that are not included by the pre-processor. This is important, since it will make it possible for the customer to test the utility.

Since the deadline of the project is 24th November, there will also be a focus on preparing a presentation and improve the report for a final delivery. The team are also going to hold a presentation for the customers developers on the 17th November, and it is important to also focus on this presentation.

\subsection{Back Log}
%--------------------
This section contains the sprint backlog \ref{tab:sprint4req} and the timetable for the sprint Table \ref{tab:sprint4time}.  

\begin{table}[!htb] \small \center
\caption{Sprint 4 Requirement Work Items \label{tab:sprint4req}}
\begin{tabularx}{\textwidth}{l X c c}
	\toprule
	& & \multicolumn{2}{c}{Hours} \\
	\cmidrule(r){3-4}
	User story & Req. and Description & Est. & Act. \\
	\midrule
	\textbf{Impl.} &  & \textbf{47} & \textbf{-} \\
	\hyperref[tab:req:stories13]{US57} & FR2-E: guess dissector from packet size & 5 & - \\
 	\hyperref[tab:req:stories10]{US41} & FR3-A mod: support \#include of system headers &  8  & - \\
	\hyperref[tab:req:stories10]{US42} & FR3-D mod: ignore \#pragma directives & 2 & - \\
	\hyperref[tab:req:stories10]{US43} & FR3-E: find include dependencies which are not explicit set & 16  & - \\
	\hyperref[tab:req:stories11]{US48} & FR4-B mod: custom Lua files support offset and value inside .cnf file & 4 & - \\
	\hyperref[tab:req:stories12]{US50} & FR4-D mod: multiple message ID's for one dissector & 2 & - \\
	\hyperref[tab:req:stories12]{US53} & FR4-H: autogenerate configuration files for structs with no config file & 1  & - \\
	\hyperref[tab:req:stories12]{US52} & FR4-I: allow configuration of size for unknown structs & 4 & - \\
	\hyperref[tab:req:stories10]{US44} & FR6-E: support C macros from CLI & 1 & - \\
	\hyperref[tab:req:stories12]{US55} & FR6-F: only generate dissectors for structs with valid id and their dependences & 4 & - \\
	\addlinespace
	\textbf{Fixes} &  & \textbf{35} & \textbf{-} \\
	& TheFIX: Be able to process customers files & 12 & - \\
	 & FR2-A: Improve generated Lua output - Remove platform prefix & 10 & - \\
	 & FR1-E: Array bug in text & 2 & - \\
	 & FR1-E: Pointer support (array) & 1 & - \\
	 & FR1-E: Enum in arrays & 1 & - \\		
	 & FR6-C: Batch mode (recursive search for subfolders) &  8  & - \\
	 & FR6-C: Support command line arguments for Cpp "--Include" (folders) & 1 & - \\
	\addlinespace
	\textbf{Testing} &  & \textbf{16} & \textbf{-} \\
	 & Fixing existing tests & 3 & - \\
	 & Add more tests for csjark module & 3 & - \\
	 & Add more tests for cparser module & 3 & - \\
	 & Add more tests for the config module & 2 & - \\
	 & Add more tests for the dissector module & 2 & - \\
	 & Add more tests for platform module & 1 & - \\
	 & Add sprint 4 end-to-end tasks & 2 & - \\
	\addlinespace
	\textbf{Doc.} &  & \textbf{10} & \textbf{-} \\
	\hyperref[tab:req:stories10]{US45} & Update command line interface doc & 1 & - \\
	\hyperref[tab:req:stories11]{US49} & Update user documentation for custom Lua & 1 & - \\
	\hyperref[tab:req:stories12]{US51} & Update user documentation for message ID & 1 & - \\
	\hyperref[tab:req:stories12]{US54} & User documentation for struct size configuration & 1 & - \\
	\hyperref[tab:req:stories12]{US56} & User documentation for generating only struct with valid ID or dependencies & 1 & - \\
	\hyperref[tab:req:stories9]{US36} & Which platforms that the utility support & 2 & - \\
	\hyperref[tab:req:stories13]{US59} & How to define new platforms to support & 1 & - \\
	\hyperref[tab:req:stories9]{US37} & Create developer manual from python docstrings & 2 & - \\
	\midrule
	& Total: & 108 &  -\\
	\bottomrule
\end{tabularx}
\end{table}

\begin{table}[!htb] \small \center
\caption{Sprint 4 Timetable\label{tab:sprint4time}}
\begin{tabularx}{\textwidth}{X c c}
	\toprule
	& \multicolumn{2}{c}{Hours} \\
	\cmidrule(r){2-3}
	Description & Est. & Act. \\
	\midrule
	\textbf{Sprint planning} & \textbf{30} & \textbf{27} \\
	\addlinespace
	\textbf{Sprint 3 requirements} & \textbf{109} & \textbf{-} \\
	Implementation & 47 & - \\
	Fixes & 35 & - \\
	Testing & 16 & - \\
	User Documentation & 11 & - \\
	\addlinespace
	\textbf{Sprint review} & \textbf{20} & \textbf{-} \\
	\addlinespace
	\textbf{Sprint documentation} & \textbf{46} & \textbf{-} \\
	Sprint 3 document & 4 & - \\
	Sprint 4 document & 42 & - \\
	\addlinespace
	\textbf{Report work} & \textbf{38} & \textbf{-} \\
	Update tables with actual hours & 2 & - \\
	Abstract - improve & 2 & -\\
	Importing user documentation to report & 3 & -\\
	Introduction section & 6 & -\\
	Report read-through from a technical perspective & 6 & -\\
	Report read-through from a non-technical perspective & 6 & -\\
	Glossary refinement & 3 & -\\
	Acronym refinement & 1 & -\\
	Write about optional requirements & 4 & -\\
	References & 3 & -\\
	Requirement agreement & 2 & -\\
	\addlinespace
	\textbf{Thales presentation} & \textbf{28} & \textbf{14} \\
	\addlinespace
	\textbf{Meetings} & \textbf{63} & \textbf{-} \\
	Advisor meetings & 28 & - \\
	Customer meetings & 14 & - \\
	Stand-up meetings & 21 & - \\
	\addlinespace
	\textbf{Project management} & \textbf{17} & \textbf{-} \\
	\midrule
	Total: & 351 & - \\
	\bottomrule
\end{tabularx}
\end{table}

\subsection{User stories}
\label{sec:req:stories4}
This section lists the user stories for the fourth sprint, these are displayed in \autoref{tab:req:stories10}, \autoref{tab:req:stories11}, \autoref{tab:req:stories12} and \autoref{tab:req:stories13}.
As we are developixng a very technical \gls{utility} we have written user stories with an implementation level of abstraction. 
These user stories represent how we intend to add the functionality of each requirement to the \gls{utility}.
The administrator in this context is the administrator at Thales Norway AS. 
The developer is the person that uses \Gls{wireshark} with the \gls{dissector} generated by CSjark.

\begin{table}[htbp] \footnotesize \center
\caption{User stories - Sprint 4 part 1\label{tab:req:stories10}}
\noindent\makebox[\textwidth]{%
\begin{tabularx}{1.2\textwidth}{l X}
	\toprule
	Header & Value \\
	\midrule
	ID & US41 \\
	Requirement & FR3-A modification: \#include system includes \\
	What & The utility needs to be able to support header files that includes system dependent headers
	even if these are not available on the platform that the utility is used on. \\
	How & The administrator is able to specify a fake system header file with the defines they need to make their structs work correctly.
	This fake header is then used to represent the system header in the so the file is parsed correctly by pycparcer.  \\
	Result & The administrator is now able to make the utility generate system dependent dissectors for headers with system dependent includes. \\
	\midrule
	ID & US42 \\
	Requirement & FR3-D: Ignoring \#pragma directives  \\
	What &  The utility needs to be able to support header files with the \#pragma directive without necessarily having a to support to functionality of the directive\\
	How & Before feeding the header files to the parser the utility needs to be able to run a pass through all of the headers that are to be parsed and remove all of the \#pragma directives encountered in those header files.\\
	Result & The user will be able to create dissectors for header files with the \#pragma directive instead of having the utility be forced to skip them. \\
	\midrule
	ID & US43 \\
	Requirement & FR3-E: Find missing includes  \\
	What & It should be possible to generate dissector from header-files, that have definitions in header-files that are not included with a preprocessor directive in the header-file.  \\
	How & The cparser module has to be able to detect when a exception is raised in the pycparser library, if an exception is raised, cparser has to search through the header-files
	to find the declaration that the pycparser library failed on, and include this header file. The cparser module will have to do this procedure until the dissector is correctly parsed in the pycparser library. \\
	Result & The utility shall be able to generate dissectors for these header-files \\	
	\midrule
	ID & US44 \\
	Requirement & Support C \#defines from CLI  \\
	What & The administrator wants to pass C \#define directives from the command-line to the preprocessor.   \\
	How & When CSjark is executed, it takes the arguments given in the command-line interface and store them in the config module.
	The \#define directives must added to the preprocessor arguments before the header-file is parsed in the pycparser library.   \\
	Result & The utility supports C \#define directives passed from the CLI. \\
	\midrule
	ID & US45 \\
	User doc & Support C \#defines from CLI \\
	What & The user wants to understand how the utility will handle C \#defines and what \#defines that are possible to pass to the CLI.   \\
	How & The user finds the correct section in the user documentation, describing the command-line interface and how C \#defines are handled.  \\
	Result & The user understands how to use C \#defines with the utility. \\
	\bottomrule
\end{tabularx}}
\end{table}

\begin{table}[htbp] \footnotesize \center
\caption{User stories - Sprint 4 part 2\label{tab:req:stories11}}
\noindent\makebox[\textwidth]{%
\begin{tabularx}{1.2\textwidth}{l X}
	\toprule
	Header & Value \\
	\midrule
	ID & US46 \\
	Requirement & FR7-A: Use Doxygen comments for "Description"  \\
	What & The utility will read Doxygen comments for a struct and use that to specify the description field for the proto object in the dissector. \\
	How & The utility will search the header files for Doxygen comments before giving the file to the preprocessor. It will note what struct the comment
	corresponds to and add it to the config module. The dissector module will look up in the config module for each struct and use the description field there if it has been found.  \\
	Result & The dissectors now requires less manual configuration because it is able to use some of the text from the header files. \\
	\midrule
	ID & US47 \\
	Requirement & FR7-B: Read int-enum config from header files \\
	What &  The utility will read \#define statements that define the allowed values and the names corresponding to those values for integers that are to be treated like enums, so that the user will not have to configure them manually.\\
	How & The utility will search the header files for define statements that correpsonds to a member that is configured to be handled as an enum. The statements needs to follow some configurable format.
	These statements are then used to auto generate a configuration file for the int member used to make an enum field for the int member when parsing the header file.\\
	Result & The utility now requires less manual configurations to make dissectors interpret certaion integers as enums. \\
	\midrule
	ID & US48 \\
	Requirement & Fetch offset in custom Lua configuration  \\
	What & The administrator should be able to add configuration in the conformance file, so it is possible to add custom Lua code with correct offset values.  \\
	How & The conformace file must support a variable for offset, and a way to use this. The config module have to read this variable, so it can be used in the dissector module to genereate a field in the dissector that uses the correct offset. \\
	Result & The Lua dissector is generated with correct offset for the custom Lua code. \\	
	\midrule
	ID & US49 \\
	User doc & Fetch offset in custom Lua configuration  \\
	What & The administrator shall learn how to use offset values in custom Lua configuration.   \\
	How & The administrator reads the section in the user documentation, about how to use custom Lua in the utility.  \\
	Result & The user will understand how to offset values in the conformance file. \\
	\midrule
	ID & US50 \\
	Requirement & FR4-D modification: Support multiple message ID's for one struct \\
	What & he administrator should be able to configure more than one message ID per struct. Therefore it is possible to use the dissector with more different messages (specified by different ID’s).    \\
	How & The configuration file must support definition of multiple ID’s. These ID’s then have to be used for registering multiple protocols for one dissector.  \\
	Result & The Lua dissector can be used with multiple messages with different ID’s. \\
	\bottomrule
\end{tabularx}}
\end{table}

\begin{table}[htbp] \footnotesize \center
\caption{User stories - Sprint 4 part 3\label{tab:req:stories12}}
\noindent\makebox[\textwidth]{%
\begin{tabularx}{1.2\textwidth}{l X}
	\toprule
	Header & Value \\
	\midrule
	ID & US51 \\
	User doc & FR4-D modification: Support multiple message ID's for one struct  \\
	What & The administrator should be able to find out how to specify multiple message ID’s for a specific struct.
	This include the proper position and syntax of the message ID’s specification. Also, he should be aware of the consequences of that definition. \\
	How & The administrator reads the configuration section in the user documentation, about how to specify multiple message ID’s for a specific struct.  \\
	Result & The administrator is able to specify and use multiple message ID’s for a specific struct. \\
	\midrule
	ID & US52 \\
	Requirement & FR4-I: Allow configuration to specify the size of unknown struct members \\
	What & The administrator should be able specify in the confirguration, how big (in bytes) is the struct member without having the member itself defined. Note: This is also a workaround for structs that are not parseable.\\
	How & The configuration should contain an optional attribute for each struct member which specifies the size of the member. If this member is a nested struct, and this struct is not defined, the size has to be specifies. Otherwise the user should be informed about that.\\
	Result & The Lua dissector can be used with C header that includes unspecified struct member. This member has only defined by its size, so it could be displayed as raw data in Wireshark. \\
	\midrule
	ID & US53 \\
	User doc & FR4-I: Allow configuration to specify the size of unknown struct members  \\
	What & The administrator should be able to find out how to specify in the confirguration, how big (in bytes) is the struct member without having the member itself defined.  \\
	How & The administrator reads the configuration section in the user documentation, about how to specify the size of the struct members. \\
	Result & The user is able to specify the size of unknown struct member. \\	
	\midrule
	ID & US54 \\
	User doc & Auto generate configuration files for structs with no corresponding configuration file \\
	What & The utility will generate template configuration files if it encounters structs with no corresponding configuration file. This is to make it easier to make such a configuration file.   \\
	How & The cparser module checks if an encountered struct has a corresponding configuration in the config module. If not, the utility writes a template file for this struct.   \\
	Result & The user will now be able to use the auto generated template file to write the configuration for a struct instead of having to start from scratch. \\
	\midrule
	ID & US55 \\
	Requirement & Only generate dissectors for structs that have a valid ID and their dependencies \\
	What & The utility should only generate dissectors for structs that have a configuration file with a valid ID and their dependencies.    \\
	How & When the utility discovers a struct definition inside a header file it should check if there exists a configuration file for that struct and if it has a valid ID.
	If not then the utility should skip that struct and continue with the header file. If a struct with a valid configuration file and ID has a member that is not defined in the current header
	file, then the utility will check the includes in the current header for the missing structs and create a dissector for them as well.\\
	Result & The utility will not generate dissectors for structs which have not been specified in the configuration.
	This gives the users of the system the ability to specify which structs they want to look at as well as shortening the time the utility needs to run.. \\
	\bottomrule
\end{tabularx}}
\end{table}

\begin{table}[htbp] \footnotesize \center
\caption{User stories - Sprint 4 part 4\label{tab:req:stories13}}
\noindent\makebox[\textwidth]{%
\begin{tabularx}{1.2\textwidth}{l X}
	\toprule
	Header & Value \\
	\midrule
	ID & US56 \\
	User doc & Only generate dissectors for structs that have a valid ID and their dependencies  \\
	What & The administrator should be able to specify in the configuration which structs should have dissectors created for them. \\
	How & The administrator reads the configuration section in the utility’s user documentation that specifies how to specify which structs should have a dissector generated for them.  \\
	Result & The user will be able to specify which structs the utility will generate dissectors for. \\
	\midrule
	ID & US57 \\
	Requirement & Guess dissector by packet size \\
	What & The utility should be able to generate a LUA file that runs with Wireshark and guesses the dissector that is to be used for a packet if it has a message ID that does not match any preexisting dissector.\\
	How & The luastructs.lua file that is generated by the utility should contain a dictonary of all dissectors sorted by the size of the structs that they are associated with.
 	When a packet with an unrecognized message ID is discovered by wireshark, the code in the luastructs.lua file should try to match the unidentified packet with a dissector
 	that has been generated with the same size as the unidentified packet. The matching dissectors should then be run with the unidentified packet. \\
	Result & Instead of only displaying the raw hex data from the unidientified packet, wireshark should display the packet as containing all of the possible structs and member values the packet might really be containing as dictated by the matching dissectors. This packet should also be displayed with a warning. \\
	\midrule
	ID & US58 \\
	Requirement & Display if struct member contains uninitialized memory \\
	What & The dissectors generated by the utility should be able to identify struct members that might possibly have uninitialized memory set as their values.
 	These members and their values should be displayed with a warning in wireshark to indicate that the values might have been uninitialized.  \\
	How & If the C-code that uses header files isn’t using memset to set the initial values of different variables a parser might decide to fill uninitialized variables with some kind of patterned garbage data.
 	This pattern might be possible to detect by the dissectors generated by the utility by adding a check to the dissector code which compares 	the member values with different known garbage-patterns generated by different parsers. \\
	Result & The utility will now be able to generate dissectors which will make wireshark display struct members and their values with a warning if they are suspected as being filled with uninitialized memory. \\	
	\midrule
	ID & US59 \\
	User doc & How to define new platforms \\
	What & The Administrator should be able to define new platform to support.  \\
	How & The user should look in the user documentation, and read the section about defining new platforms. \\
	Result & After the administrator has defined the new platform, the utility should be able to generate dissectors for the new platform. \\	
	\bottomrule
\end{tabularx}}
\end{table}

%----------------------
\section{System Design}
%----------------------


%-----------------------
\section{Implementation}
%-----------------------

\subsection{Include Unsupported System-headers}
%--------------------
TODO

\subsection{Ignore \#pragma Directives}
%--------------------
TODO

\subsection{Improve Generated Lua Output}
%--------------------
TODO

\subsection{Support Subfolders in Batch Mode}
%--------------------
TODO

\subsection{Support for Customer Examples}
%--------------------
TODO

%-----------------------
\section{Sprint Testing}
%-----------------------


%--------------------------
\section{Customer Feedback}
%--------------------------


%--------------------------
\section{Sprint Evaluation}
%--------------------------


