%============================
\chapter{Preliminary Studies}
%============================
This chapter presents the preliminary studies for this project.
In \autoref{sec:pre:similar} we have examined existing solutions, and in
\autoref{sec:pre:method} we provide a description of two popular software
development methodology.

Wireshark, which out utility should create dissectors for, are described in
\autoref{sec:pre:wireshark}.
\hyperref[sec:pre:langs]{Section \ref*{sec:pre:langs}} contains the different
programming languages we might use, while \autoref{sec:pre:parsers}
describe possible solutions for parsing C header files.
\hyperref[sec:pre:config]{Section \ref*{sec:pre:config}} outlines possible
configuration libraries, and \autoref{sec:pre:testing} discusses possible unit
testing frameworks. In \autoref{sec:pre:docs} we describe tools for creating
user documentation and \autoref{sec:pre:ide} describes three integrated
development environments.

\hyperref[sec:pre:eval]{Section \ref*{sec:pre:eval}} provides the
justifications for the choices we have made, and in
\autoref{sec:pre:framework} we describe the framework our utility will require.
At the end of the chapter, in \autoref{sec:pre:license}, we describe the
license of our utility.


%--------------------------
\section{Similar Solutions}
%--------------------------
\label{sec:pre:similar}
We started by searching for existing solutions in the problem space. This
search turned up idl2wrs\footnote{\url{http://wiki.wireshark.org/idl2wrs}}.
The other solution was suggested by our customer,
Asn2wrs\footnote{\url{http://wiki.wireshark.org/Asn2wrs}}.
Both of these solutions are bundled with Wireshark.

\subsection{idl2wrs}
%-------------------
A tool for generating Wireshark dissectors from IDL files. The tool is written
in Python, and generates dissectors in C from IDL specifications. Interface
Description Language (IDL) is used to interface in a language-neutral way,
which enables communication between software of different languages. It is
used for example in Sun RPC and CORBA. Since idl2wrs takes input in a different
language than us, and creates dissectors in a different language than us, we
can not reuse any of its code. Instead we will look at its architecture and
data structures, especially how it generates dissectors.

\subsection{Asn2wrs}
%-------------------
A tool for generating Wireshark dissectors from ASN.1 protocols. It requires
four input files: an ASN-1 protocol description, a configuration file and two
template files. Advantages of using Asn2wrs are faster development from
easier recompilation, and plugins which are easy to distribute. Disadvantages
are that code and makefiles are more complex. Our customer can't use this
solution as it would require them to rewrite their C structs to ASN.1
descriptions, which would take very long time.


%-----------------------------------------
\section{Software Development Methodology}
%-----------------------------------------
\label{sec:pre:method}
In this section we describe two popular software development methodologies,
while \autoref{sec:pre:devchoice} discusses which one we decided to use, and
why.

\subsection{Waterfall}
%---------------------
\label{sec:pre:waterfall}
Waterfall is a software development methodology based on sequential phases.
It consist of the following phases: requirement specification, design,
implementation, integration, testing, deployment, and maintenance. In its pure
form, these phases are non overlapping and one way only, which means that each
phase must be fully completed before the next can begin.

\subsubsection{Requirement specification}
This phase is about receiving requirements from a customer and then formalising
these into concrete functional and non-functional requirements. These will
again be further broken down into smaller work items that are easy to quantify
in terms of time of use and importance. These metrics may help distinguish
which features are to be prioritised.

\subsubsection{Design}
The design phase is about planning how to implement the features from the
requirement phase. The goal is to make a precise software architecture for the
project that dictates most of the implementation phase. This may include (but
not limited to) making class diagrams, data flow diagrams, state machines, user
interface mock-ups, etc.

\subsubsection{Implementation}
This phase is about implementing/coding the design made in the design phase on
a component level.

\subsubsection{Integration}
This phase is about integrating the different components that results from the
implementation phase.

\subsubsection{Testing}
The testing phase aims to thoroughly test the result of the implementation and
integration phase. The goal is to find and fix bugs introduced in both these
phases.

\subsubsection{Deployment}
The deployment phase is about delivering the resulting software to the
customer. This may include installing the software on their systems. This is
also the phase where the customer either accepts or rejects the resulting
software.

\subsubsection{Maintenance}
Large software projects are almost impossible to get completely bug free, and
therefore a certain amount of maintenance may be required. The obvious tasks
are to either fix or provide viable workarounds for problems that appear during
normal use. Maintenance may also include developing new features that the
customer finds the need for.

\subsection{Scrum}
%-----------------
\label{sec:pre:scrum}
Scrum is an agile development methodology based on the philosophy that it is
impossible to completely and accurately plan everything in a software project
before you begin. It is therefore more or less based on iterations of the
waterfall phases described in \autoref{sec:pre:waterfall}, but instead of
having these phases being strictly sequential, they are run in a more
'as needed' basis. Each iteration in scrum is called a sprint and is typically
lasting from two and up to four weeks. This time period is fixed for each
project, so the sprint will always end on time. To make this possible, features
that are not completed on time is deferred to a later sprint. Each sprint
should result in a runnable product that potentially could deliver some value
to the customer, even if this requires some redundant work.

\subsubsection{Main scrum roles}
\begin{description}
	\item[Scrum master] has the responsibility of maintaining the process and
		for removing obstacles for other team members. In short, the scrum
		master tries to keep the other team members focused on their tasks.
	\item[Product owner] represents and speaks for the customer. Not
		necessarily a part of the customers organization, but must have the
		stated authorities.
	\item[Team members] responsible for making and delivering the product.
		Should consist of a self organizing team of five to nine persons with
		cross functional skill set.
\end{description}

\subsubsection{Scrum artifacts}
\begin{description}
	\item[Product backlog] contains a high level description of all the desired
		features for the project. These should be prioritised based on their
		business value and evolve along with the project.
	\item[Sprint backlog] contains what the team is committed to complete over
		the next sprint. These commitments are features broken down into work
		items. These items should not be larger than 16 hours of work, and they
		should be described so that everyone in the team could contribute to
		implementing them.
	\item[Burn down chart] A daily updated chart consisting of what work
		remains in the sprint. Its purpose is both to show what work to do next
		and to give a visual representation of the work progress.
\end{description}

A sprint begins with the sprint planning meeting, which consists of two
stages. In the first, the team and the product owner prioritizes the product
backlog. In the second, the team discusses what features they can commit to
(based on priority) and brake these down into work items, which are added to
the sprint backlog. This should include giving each item an estimated
completion time.

The sprint itself consists of producing what is required for completing work
items, updating the burn down chart, and daily scrum meetings. In these daily
meetings each team member provides a short update of what they did the day
before, what they plan to do today and what problems might be in their way.
These problems should not be discussed in this meeting, but rather dealt with
separately after the meeting (this is the scrum masters responsibility).

At the end of the sprint cycle, the team should hold a scrum review meeting.
This meeting is about discussing what was completed and what was not, and to
demonstrate the completed features for the customer.

After the review meeting, a separate retrospect meeting should be held with all
the team members where all members shares their reflections of how the sprint
went and how to improve the next sprint. This is important for improving the
process.


%------------------
\section{Wireshark}
%------------------
\label{sec:pre:wireshark}
\begin{wrapfigure}{r}{3.5cm}
	\vspace{-10pt}
	\includegraphics[width=3.5cm]{./planning/img/wireshark_logo}
	\vspace{-20pt}
\end{wrapfigure}
Wireshark\footnote{\url{http://www.wireshark.org/}} is a free, open source
network protocol analyzer. It lets you capture and browse traffic running
through a computer network. Wireshark is currently being developed by the
Wireshark team, a group of networking experts spanning the globe. Because of
its rich set of features and ease of use, Wireshark is de facto standard in
many different industries and the educational community. Wireshark is able to
dissect and display data from a plethora of different protocols. One of its
strengths lies in the ease of which developers can add their own dissectors,
post-dissectors and taps.

Dissectors can be written in either C or Lua. Most dissectors are written in C
for increased speed. Lua-scripts are mostly used as prototypes or to process
non time crucial data as they don't need compilation to be used. Our customer
uses Wireshark not only to browse through and filter regular networking
traffic, but also for monitoring inter-process communication where it is
important to have a tool which can easily be extended to dissect and display
structures and data types unique to the organization.

Our utility should read C header files and create Wireshark dissectors written
in Lua for structs found in the header files.


%------------------------------
\section{Programming Languages}
%------------------------------
\label{sec:pre:langs}
The dissectors we have to generate are written in Lua, and we have looked at
both Java and Python programming language for our utility. In this section we
describe these different languages. In \autoref{sec:pre:langchoice} we describe
which language we selected and why.

\subsection{Lua}
%---------------
\begin{wrapfigure}{r}{2.5cm}
	\vspace{-10pt}
	\includegraphics[width=2.5cm]{./planning/img/lua_logo}
	\vspace{-20pt}
\end{wrapfigure}
Lua\footnote{\url{http://www.lua.org/}} is a multi-paradigm, dynamically typed
programming language which is designed to be lightweight so it can easily be
embedded into applications. Lua has only a few basic data structures: boolean,
numbers, strings and table. Still Lua implements advanced features such as
first-class functions, garbage collection, closures, coroutines and dynamic
module loading. Lua was created in 1993 at the Pontifical Catholic University
of Rio de Janeiro, in Brazil.

The output of our utility will be Wireshark dissectors written in Lua. While
Wireshark supports dissectors written in both C and Lua, Lua is preferred
because they can be added without recompiling Wireshark. Lua dissectors
interface with Wireshark through a simple API.

\subsection{Java}
%----------------
\label{sec:pre:java}
\begin{wrapfigure}{r}{1.3cm}
	\vspace{-30pt}
	\includegraphics[width=1.3cm]{./planning/img/java_logo}
	\vspace{-30pt}
\end{wrapfigure}
Java\footnote{\url{http://java.com/}} is an object-oriented, structured,
imperative, statically typed programming language. It was originally developed
by Sun Microsystems, which is now a subsidiary of Oracle Corporation. Java was
released in 1995, and it derived much of its syntax from C and C++, but with
fewer low-level facilities. Java’s strength are portability, automatic memory
management, security, good documentation and an extensive standard library.
Java has several tools and libraries of varying quality for creating parsers,
for example ANTLR and JAVACC. A detailed description of ANTLR can be found in 
\autoref{sec:pre:antlr}.

\subsection{Python}
%------------------
\label{sec:pre:python}
\begin{wrapfigure}{r}{2cm}
	\vspace{-20pt}
	\includegraphics[width=2cm]{./planning/img/python_logo}
	\vspace{-20pt}
\end{wrapfigure}
Python\footnote{\url{http://www.python.org/}} is a general-purpose,
multi-paradigm, object-oriented, imperative, dynamically typed programming
language. It was created by Guido van Rossum, and is today developed by Python
Software Foundation and the Python community. Python’s strength include
automatic memory management, large and comprehensive standard library,
portability, powerful but very clear, concise and simple syntax. There exists
several pure Python libraries for creating lexers and parsers, like PLY,
pycparser and cppheaderparser. These are described further in
\autoref{sec:pre:parsers}.


%-----------------------------------
\section{Parsers Libraries \& Tools}
%-----------------------------------
\label{sec:pre:parsers}
This section contains various tools and libraries we have looked at for solving
the challenge of parsing C header files. They range from language-independent
tools like GCC and Clang to Python-only libraries like PLY and pycparser. The
justification for the libraries we selected can be found in
\autoref{sec:pre:parserchoice}.

\subsection{ANTLR}
%-----------------
\label{sec:pre:antlr}
\begin{wrapfigure}{r}{2.5cm}
	\vspace{-20pt}
	\includegraphics[width=2.5cm]{./planning/img/antlr_logo}
	\vspace{-20pt}
\end{wrapfigure}
ANTLR\footnote{\url{http://www.antlr.org/}}, ANother Tool for Language
Recognition, is a compiler toolkit for creating lexers and parsers from grammar
files. It can create these compilers for several different target languages,
including Java and Python. There exists ANTLR grammar files for the challenges
we are facing: parsing C, C preprocessor step and parsing ASN.1. These grammars
configure ANTLR to create Java lexers and parsers which reads and validates
inputted source code files.

\subsection{PLY}
%---------------
PLY\footnote{\url{http://www.dabeaz.com/ply/}} is a Python alternative to the
popular lexer and parser compilers lex and yacc. It also comes with a 95\%
completed C preprocessor in case we are required to modify the preprocessor
for our utility. Other special purpose parsers like pycparser and
cppheaderparser depends on PLY. These are described later in this section.

\subsection{pycparser}
%---------------------
\label{sec:pre:pycparser}
There are two Python libraries for parsing C with the same name (but different
capitalization), pycparser\footnote{\url{http://code.google.com/p/pycparser/}}
and PyCParser\footnote{\url{https://github.com/albertz/PyCParser}}. While they
both aim to solve almost the same problem, the first one appears to have better
documentation, is a more mature project and support more of the C99
specification. pycparser requires PLY to work.

\subsection{cppheaderparser}
%---------------------------
Cppheaderparser\footnote{\url{http://sourceforge.net/projects/cppheaderparser/}}
is a parser for C++ header files written in Python. It is an alternative for
pycparser in case we need to parse C++ files instead of simple C header files.
It also depends on PLY.

\subsection{GCC}
%---------------
\label{sec:pre:gcc}
\begin{wrapfigure}{r}{1.5cm}
	\vspace{-20pt}
	\includegraphics[width=1.5cm]{./planning/img/gcc_logo}
	\vspace{-20pt}
\end{wrapfigure}
GNU Compiler Collection\footnote{\url{http://gcc.gnu.org/}} (GCC) is a
compiler system which has front ends which parse C and C++ code, and is written
in C and C++. It can be used in our utility as an external tool which does the
parsing and then outputs an intermediate language representation which we can
parse/search to find the C struct definitions. Its drawbacks are a lack of
flexibility if we need to change its behaviour, and we will still need to write
a custom parser or use something like GCC-XML and an XML parser.

\subsection{Clang}
%-----------------
\label{sec:pre:clang}
\begin{wrapfigure}{r}{2.5cm}
	\vspace{-20pt}
	\includegraphics[width=2.5cm]{./planning/img/llvm_logo}
	\vspace{-20pt}
\end{wrapfigure}
Clang\footnote{\url{http://clang.llvm.org/}} is a compiler front end for C, 
C++, Objective-C and Objective-C++, written in C++. Clang differ from GCC as it
behaves as a library rather than an external tool, but for Java we will have to
use it like GCC because there are no Java-Clang bindings. It supports
outputting the abstract syntax tree as XML, which our utility then will need to
parse. Clang provides bindings for Python so there it can be used as a library,
but its main drawback is, like GCC, a lack of flexibility. Clang is a part of
the LLVM toolkit.


%---------------------------------
\section{Configuration Frameworks}
%---------------------------------
\label{sec:pre:config}
This section looks at different configuration frameworks for Python. Which we
selected and why is explained in \autoref{sec:pre:configchoice}.

Our utility needs a flexible configuration, as some of the information we
shall display does not exist in the files we parse. For example there are no
clear relationship between enumerated values in messages and their names.
These must be provided through a configuration. The configuration should also
support the following:
\begin{itemize}
	\item Defining data constraints, so the dissector can recognize invalid
		values for a struct member.
	\item Defining custom handling of special data types.
	\item Allow custom Lua dissectors to be defined and used in special cases.
\end{itemize}

\subsection{ASN.1}
%-----------------
Abstract Syntax Notation One (ASN.1) is a notation for describing data
structures, the standard is defined by ISO 8824. ASN.1 is used for
representing, encoding, transferring and decoding of data. It provides a
fundamental tool to be used in application, which make it possible to exchange
information in a independent way. There exist two Python libraries for parsing of 
ASN.1, none of them are updated to latest version of Python.

\subsection{YAML}
%----------------
\label{sec:pre:yaml}
\begin{wrapfigure}{r}{3cm}
	\vspace{-30pt}
	\includegraphics[width=3cm]{./planning/img/pyyaml_logo}
	\vspace{-30pt}
\end{wrapfigure}
YAML\footnote{\url{http://yaml.org/}} (YAML Ain't Markup Language) is a data
serialization format. It's designed to be easy to read and write for humans.
YAML syntax was designed to be easily mapped to data types common to most
high-level languages. While most programming languages can use YAML for data
serialization, YAML excels in working with those languages that are
fundamentally built around the three basic primitives. These include the new
wave of agile languages such as Perl, Python, PHP, Ruby, and Javascript.

PyYAML\footnote{\url{http://pyyaml.org/}} is a YAML parser for the Python
programming language, and it is available for both the 2.x and 3.x branch of
Python. It is licensed under MIT license.

\subsection{configparser}
%------------------------
configparser\footnote{\url{http://docs.python.org/py3k/library/configparser.html}}
is a Python module to manage user-editable configuration files. The
files are organized into sections, and each section can contain name-value
pairs for configuration data. Value interpolation using Python formatting
strings is also supported, to build values that depend on one another.

configparser module is a part of Python standard library, and therefore does
not require installation or configuration to use.

\subsection{ConfigObj}
%---------------------
ConfigObj\footnote{\url{http://www.voidspace.org.uk/python/configobj.html}} is
a simple but powerful config file reader and writer (originally based on
ConfigParser). Its main feature is that it is very easy to use, with a
straightforward programmer's interface and a simple syntax for config files.
Among others, it has these additional features:
\begin{itemize}
	\item Nested sections (subsections), to any level
	\item List values
	\item Multiple line values
	\item String interpolation (substitution)
	\item Integrated with a powerful validation system
\end{itemize}

\noindent Currently, ConfigObj module exists only for Python up to version
2.7. It is under BSD license.


%--------------------------------
\section{Unit Testing Frameworks}
%--------------------------------
\label{sec:pre:testing}
There are many different unit testing frameworks for Python. We have evaluated
three of them, to see which best suits our utility, which we describe in this
section. In \autoref{sec:pre:testchoice} we describe which we selected and why.

\subsection{py.test}
%-------------------
py.test\footnote{\url{http://pytest.org/latest/}} a mature full-featured testing
tool. It runs on Python 2.4-3.2, PyPy and Jython-2.5.1 intepreters on both
Windows and Posix platforms. It is well documented and popular in the Python
community. The best known project which uses it is PyPy, which has over 16,000
unit tests. py.test discoverers tests automatically by searching for modules,
classes, functions and methods which starts with "test\_". It uses the assert
statement to test variables and values. These implicit behaviours makes tests
easier to write and faster, but harder to learn and understand.

\subsection{nose}
%----------------
nose\footnote{\url{http://readthedocs.org/docs/nose/en/latest/}} testing
framework extends Python's unittest library to make testing easier.
It provides an alternative test discovery and running process for unittest,
which is intended to mimic the behavior of py.test as much as is reasonably
possible without resorting to too much magic. nose support easy-to-write
plugins, and it comes bundled with the most popular ones. It supports both
Python 2.x and 3.x branches.

\subsection{Attest}
%------------------
\label{sec:pre:attest}
\begin{wrapfigure}{r}{3.2cm}
	\vspace{-20pt}
	\includegraphics[width=3.2cm]{./planning/img/pocoo_logo}
	\vspace{-30pt}
\end{wrapfigure}
Attest\footnote{\url{http://packages.python.org/Attest/}} is a test automation
framework for Python emphasising modern idioms and conventions. It supports
test collecting using Python decorators, introspection of the assert statement,
treating tests as Python modules rather than scripts. Attest is a rather young
framework, with limited features and documentation. Attest is a sub-level
project of the Pocoo project.

\subsection{coverage.py}
%-----------------------
coverage.py\footnote{\url{http://nedbatchelder.com/code/coverage/}} is a tool
for measuring code coverage of Python programs. It is typically used to measure
the effectiveness of unit tests, by showing which parts of the code are
exercised by tests. coverage.py support Python 2.3 to 3.2. It can output
results in plain text, html and XML.


%---------------------------------
\section{User Documentation Tools}
%---------------------------------
\label{sec:pre:docs}
Some of the non-functional requirements for our utility is user documentation.
In this section we describe a tool for writing such documentation, and a free
hosting site for our user documentation.

\subsection{Sphinx}
%------------------
\begin{wrapfigure}{r}{2.7cm}
	\vspace{-20pt}
	\includegraphics[width=2.7cm]{./planning/img/sphinx_logo}
	\vspace{-20pt}
\end{wrapfigure}
Sphinx\footnote{\url{http://sphinx.pocoo.org/}} is a Python tool for writing
documentation, that makes it easy to create intelligent and beautiful
documentation. It is used for the standard Python documentation, and it is
popular in the Python community. Sphinx uses reStructuredText as its markup
language, which is a easy-to-read, what-you-see-is-what-you-get plain text
markup syntax and parser system. Our use case for sphinx is writing
documentation for our utility, how to use it and configure it. Sphinx can
generate output in several different formats, including html and latex/pdf.

\subsection{Read the Docs}
%-------------------------
\begin{wrapfigure}{r}{1.2cm}
	\vspace{-20pt}
	\includegraphics[width=1.2cm]{./planning/img/readthedocs_logo}
	\vspace{-20pt}
\end{wrapfigure}
Read the Docs\footnote{\url{http://readthedocs.org/docs/read-the-docs/}} is
free hosting of documentation for the open source community. It supports Sphinx
docs written with reStructuredText, and it can automatically pull from Git,
Subversion, Bazaar, and Mercurial repositories. We can configure it so it
automatically pulls and compiles our user documentation from our github
repository whenever we push any changes.


%-------------------------------------------
\section{Integrated Development Environment}
%-------------------------------------------
\label{sec:pre:ide}

\subsection{PyCharm}
%-------------------
\begin{wrapfigure}{r}{3.5cm}
	\vspace{-20pt}
	\includegraphics[width=3.5cm]{./planning/img/pycharm_logo}
	\vspace{-20pt}
\end{wrapfigure}
PyCharm\footnote{\url{http://www.jetbrains.com/pycharm/}}
is a cross platform, proprietary IDE for Python. It has good support
for text editing, syntax highlighting, auto indentation, code navigation, code
completion and automatic error checking. There is also a decent debugger and
unit test support that can help finding errors and integrated version control
support (including git), which makes it easy to synchronize with a remote
repository. Most mentioned functions is also paired with keyboard shortcuts.

The downside with PyCharm is that it requires a relative expensive license. It
is, however, possible to apply for classroom licenses that are free of charge.
The latter is a requirement to make this IDE a viable option.

\subsection{PyScripter}
%----------------------
\begin{wrapfigure}{r}{3cm}
	\vspace{-20pt}
	\includegraphics[width=3cm]{./planning/img/pyscripter_logo}
	\vspace{-20pt}
\end{wrapfigure}
PyScripter\footnote{\url{http://code.google.com/p/pyscripter/}}
is a Windows only, open source IDE for Python. It has support for
basic text editing functions relevant to programming like syntax highlighting,
auto indentation, code completion, debugger and file management. It also has
some support for navigation the code, for example by offering to find the next
point in the code that references a certain variable or function. The mentioned
function mostly has keyboard shortcuts.

It does not have support for automatic error checking in the program, so it
will no alert the user of spelling and syntax errors. It also lacks integration
with any version control systems like git or svn. The code completion and
code navigation is a little lacking. It will for example not suggest importing
files if you reference a class from another module and it cannot give a
complete list of usages of a function.

\subsection{Vim}
%---------------
\begin{wrapfigure}{r}{1.5cm}
	\vspace{-20pt}
	\includegraphics[width=1.5cm]{./planning/img/vim_logo}
	\vspace{-20pt}
\end{wrapfigure}
Vim\footnote{\url{http://www.vim.org/}} is cross-platform, open source text
editor originally created for the Amiga. It is not regarded as an IDE, but it
provides all the regular features of text editors, including syntax
highlighting, auto-completion, auto-indentation, searching, multiple undo and
redo. It can be configured to support almost everything modern IDE’s support,
and its extensive customizability is considered parts of its strength. But it
is also parts of its weakness, it is very difficult for new Vim users to learn
how to use it effectively. Therefore we do not suggest any team member which is
not already experienced with Vim to try it.

\subsection{Summary}
%-------------------
PyCharm is by far the best IDE evaluated in terms of functionality, and it is
the one that mirrors Eclipse the most, which is an advantage, since most team
members are best acquainted with Eclipse. It will be the recommended IDE for
this project, given that we can acquire classroom licenses.

On the other hand, there is no real reason to dictate the use of IDE, since
what determines the productivity of a team member is more how well you know
the specific tool you are using. It will therefore be up to each team member
to choose what IDE/text editor they want to use.


%----------------------------------
\section{Evaluation and Conclusion}
%----------------------------------
\label{sec:pre:eval}
In this section we provide a justification for the choices we have made in
regards to process, programming language, and libraries we will use. Then
in \autoref{sec:pre:framework} we give a brief description of the framework
we will construct for our utility.

\subsection{Development Process Choice}
%--------------------------------------
\label{sec:pre:devchoice}
We have chosen \hyperref[sec:pre:scrum]{scrum} for our development strategy.
We do not have a lot of experience with software development either
individually or as a group, so we have little personal knowledge of how much
we are able to produce, and the task may present challenges that we are not
prepared for when the project starts. For these reasons we believe that we
need to take an agile approach to this project. This way, we may both learn as
we go, an adjust later iterations by the result of the previous. We may also
have something to deliver even if we do not have time to implement all the
desired features.

The scrum methodology fits these goals perfectly, and is therefore a natural
choice. The risk factor here is that all team members are mostly unfamiliar
with scrum, while we have at least a little knowledge about waterfall. We do,
however, think that the time and risk of learning will not be much compared to
the benefit it will give us over waterfall.

\subsection{Programming Language Choice}
%---------------------------------------
\label{sec:pre:langchoice}
We originally selected \hyperref[sec:pre:java]{Java} as our programming
language because it would run on all the platforms required, it offered
automatic memory management so it would be easier to debug, and it was the only
language everyone on the team had experience with.

We looked at \hyperref[sec:pre:antlr]{ANTLR} for generating
C lexer and parser in Java, which looked very promising. It also provided
grammar files for creating a C preprocessor in Java. Closer evaluation revealed
that the C preprocessor grammar was written in 2006, and had stopped working in
2008 as newer versions of ANTLR was not backwards compatible. Also the
generated C parser only validated C code, it did not create an abstract syntax
tree which we could traverse. This meant that using Java and ANTLR would
require us to modify these grammars to suite our needs, and ANTLR's lack of
documentation became a huge risk for our project.

These issues and feedback from our customer made us evaluate Python for
developing our utility. We found several libraries for parsing C files, and
even one for parsing C++ header files. These are described in
\autoref{sec:pre:parsers}.

We decided to use \hyperref[sec:pre:python]{Python} for this project because
the parsing libraries for Python came in working condition with decent
documentation, and because we were able to create a small working prototype
in Python in just a few hours. We estimate that it would take at least a week
to achieve the same result in Java.

A challenge with our decision is the fact that not all team members have
sufficient experience with Python. Most team members must therefore do some
self study before we start the first sprint.

\subsection{Parsers Libraries \& Tools Choice}
%---------------------------------------------
\label{sec:pre:parserchoice}
We outlined three different approaches for parsing C header files. First is
write a custom parser ourself, second is to use a C parsing library, and
third is using a toolkit parser like \hyperref[sec:pre:gcc]{GCC} and
\hyperref[sec:pre:clang]{Clang}.

We felt that writing our own C parser with C preprocessor would possibly take
up a lot, if not all, of the available project time. The third option would add
a large dependency which our customer want to avoid, if possible. GCC and Clang
can be challenging to install and use on Windows.

Therefor using a C parser library would be the best solution, and as mentioned
above, Java with ANTLR proved challenging. So we evaluated Python parser
libraries.

We decided to use \hyperref[sec:pre:pycparser]{pycparser}. We favored pycparser
over PyCParser and cppheaderparser because it has better documentation, it
seemed to be a more mature project, and it supports the most of the C99
specification. pycparser depends on PLY, so our utility will also depend on it.

For C preprocessor we have selected to use a tool for Windows which comes with
pycparser, on Mac we will use the one which comes with XCode, and on other
platforms we will either use GCC or tools which comes with the platform. If we
need to modify a C preprocessor we might use PLY's incomplete C preprocessor.

\subsection{Configuration Framework Choice}
%------------------------------------------
\label{sec:pre:configchoice}
We have listed a summary of some of the advantages and drawbacks of the
different configuration frameworks we looked at in \autoref{tab:pre:config}.
\begin{table}[htbp] \footnotesize \center
\caption{Configuration summary\label{tab:pre:config}}
\noindent\makebox[\textwidth]{%
\begin{tabularx}{1.1\textwidth}{X X X X X}
	\toprule
	& YAML & configparser & ConfigObj & ASN.1 \\
	\midrule
	Advantages &
	+Simplicity\newline +Flexibility &
	+Easy to use &
	+Easy to use\newline +Flexibility\newline +Nesting\newline +Type \newline\hspace*{3mm}validation &
	+Customer \hspace*{3mm}wants it \\
	\addlinespace
	Drawbacks &
	-External library\newline -No type \newline\hspace*{2mm}validation &
	-Lacks nesting\newline -Lacks lists\newline -No type \newline\hspace*{2mm}validation &
	-External library\newline -Lacks lists &
	-External library\newline -Too generic \\
	\addlinespace
	Latest version & 3.10 & 3.2 & 4.7.2 & 0.0.13 \\
	Python branch & 2.7 and 3.3 & 2.7 and 3.3 & 2.7 & 2.7 \\
	License & MIT & PSF L & BSD-new & BSD \\
	\bottomrule
\end{tabularx}}
\end{table}

We decided to use \hyperref[sec:pre:yaml]{YAML} for handling configuration
files, as it covered most of our requirements. Because we decided to use the
latest version of Python, version 3.2.2, the range of possible configuration
frameworks was reduced. Therefore, although ASN.1 and ConfigObj are very
suitable for our task, they were eliminated (those parsers are available
only up to version 2.7), which left us 2 main possibilities: YAML and
configparser. configparser turned out to be insufficient for us, mainly because
it lacked lists. These we need for description of hierarchical structures of
the C headers. YAML has only two minor disadvantages we should be aware of.
First, there is no type validation mechanism, so we will have to create our
validation manually. Second, it is an external library. We find this drawback
minor for now but it can turn out to be a problem in the future. Except for
these issues, YAML, more specifically pyYAML, seems to have a good potential
for creating flexible configuration support for our utility.

\subsection{Unit Testing Framework Choice}
%-----------------------------------------
\label{sec:pre:testchoice}
The three frameworks we looked at  are very similar, being modern Python
testing frameworks. They differ in maturity and what is often called magic in
the Python community.

py.test is the most mature but also the most magic, it uses a lot of
introspection to discover tests and it has no API. nose is heavily influenced
by py.test, but it tries to be more explicit, and provides an API. Attest is
the youngest testing framework, and like nose, has less magic and focuses on
providing a very pythonic API. Being the youngest also means it has the least
documentation, functionality and plugins. Therefore Attest might be the easiest
testing framework to learn. Therefor we decided to use
\hyperref[sec:pre:attest]{Attest} for unit testing of our utility.

\subsection{Our Framework}
%-------------------------
\label{sec:pre:framework}
Our utility will need to take as input C header files, search through them to
find struct definitions, and create Lua scripts which dissects the structs in
\hyperref[sec:pre:wireshark]{Wireshark}.

To find the structs we will use pycparser to parse the input files, create an
abstract syntax tree, and to find the struct definitions. We will use pyYAML to
read configuration from file, which together with the struct definitions will
be placed in some suitable data structures for generating dissectors.

The versions of the different tools and libraries we are using can be found in
\autoref{tab:pre:versions}.
\begin{table}[!h] \footnotesize \center
\vspace{-10pt}
\caption{Versions of tools and libraries\label{tab:pre:versions}}
\begin{tabular}{l l l}
	\toprule
	Library/Tool & Version & Why \\
	\midrule
	Python & CPython 3.2.2 & Latest stable standard Python implementation \\
	pycparser & 2.05-dev & Development version, for \_Bool support \\
	pyYAML & 3.10 & Latest stable version \\
	PLY & 3.4 & Latest stable version \\
	Attest & 0.6-dev & Development version, for Python 3.2 support \\
	Sphinx & 1.0.8 & Latest stable version \\
	WireShark & 1.7.0-SVN & Latest nightly build, for Lua support \\
	\bottomrule
\end{tabular}
\vspace{-10pt}
\end{table}


%-----------------------------
\section{IP Rights \& License}
%-----------------------------
\label{sec:pre:license}
The customer has explained that they do not intend to distribute our utility,
and that we are free to license it as open source if we want to, under
whichever license we feel is most suited. They suggested GNU GPL as Wireshark
is released under it.

We needed to consider the licenses of the libraries and tools we depend upon
when we decided which license to use. This is summarized by
\autoref{tab:pre:licenses}.
\begin{table}[!h] \footnotesize \center
\vspace{-20pt}
\caption{Licenses\label{tab:pre:licenses}}
\begin{tabular}{l l}
	\toprule
	Wireshark & GNU GPL \\
	PLY & BSD-new \\
	pycparser & BSD-new \\
	pyYAML & MIT \\
	\midrule
	Our utility & BSD-new \\
	\bottomrule
\end{tabular}
\vspace{-10pt}
\end{table}

\noindent Some of the requirements for our utility might require us to modify
the C preprocessor in PLY and the pycparser library, which made us consider
the new 2-clause BSD license the most suited for us. Since it also gives us the
option to later move to a more restrictive license like GPL, we decided to use
it.
