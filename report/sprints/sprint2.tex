%=================
\chapter{Sprint 2}
%=================

%------------------------
\section{Pre-sprint}
%------------------------
Sprint 1 gave the desired result, but the team was not satisfied with the way the Scrum process was conducted, especially the sprint planning. In sprint 1 retrospect we decided to conform more to, in our mind, proper Scrum. Applying experience and advice from the first sprint, to get a better process. 

This planning meeting we will try to have more descriptive work items in the sprint backlog. This will ease the process of design, implementation, testing and documentation of the utility, and we do not have to redo any parts that will end up in the report in order to assist the reader. We focus on good user stories to ensure that the elements are low enough level.


%------------------------
\section{Sprint Planning}
%------------------------
The first sprint resulted in a solid core for the utility. During the next sprint iteration, the core will be extended with more advanced functionality. After this sprint, the utility will have most of the functionalities it need to work in a real environment, and will probably be able to aid Thales in some of their operations.

Not yet understanding the complexity of all the requirements in the sprint backlog, the team ended in an uncertain person-hours estimate for some work objects. Time will show if we understood the complexity and assigned enough hours to implement it. The more complex, but not so critical functionalities will be part of sprint 3 and 4.   



\subsection{Duration}
%-----------------------
According to the work breakdown structure, \autoref{tab:wbs}, the planning meeting of the second sprint should have been conducted the 5th of October. After a request from the customer to see our planning for the second sprint at the weekly customer meeting, which was scheduled to be before our planning meeting the same day, we decided to advance the planning to the 4th of October. This is to maintain the good relationship to the customer and submit to their preference.

The sprint started with the planning meeting the 4th of October and our work started the following day. The sprint duration is 14 days, and will end the 18th of October with a review meeting.  

\subsection{Sprint Goal}
%-----------------------
The second sprint will build on the core created in the first sprint. During the sprint we will extend the functionality with more comprehensive and advanced features. Most of the requirements we intend to fulfill in this sprint had to be done subsequent to the first sprint, because the structure and design of the core had to be in place first. The requirements that are selected for this sprint is a natural advancement on the way to make the utility that the customer wants. 

One of the most crucial functions to work in a real environment, is the support for nested header-files. The handling of the \#include-statement gives the utility this feature. The goal of the sprint is to implement the \#include and mainly to have support for enums, bit streams, endianness and batch mode. 


\subsection{Back Log}
%-----------------------
The second sprint we will implement thirteen requirements. These are listed in Table
\ref{tab:sprint2req1} and Table \ref{tab:sprint2req2}.

\begin{table}[!ht] \small \center
\caption{Sprint 2 Requirements\label{tab:sprint2req1}}
\begin{tabularx}{\textwidth}{l l X c c}
	\toprule
	& & & \multicolumn{2}{c}{Hours} \\
	\cmidrule(r){4-5}
	\# & Req. & Description & Est. & Act. \\
	\midrule
	1 & FR1-B & Support members of type enums & \underline{ 6 } & 5 \\
	   &  & Implementation			   	& 3 & 2\\
	   &  & Testing - unit				   	& 1 & 1\\
	   &  & Testing - end to end			& 2 & 2\\
	\addlinespace
	2 & FR1-C & Support members of type structs & \underline{ 7 } & 3.5  \\
	   &  & Implementation			   	& 6 & 3\\
	   &  & Testing - unit				   	& 1 & 0.5\\
	\addlinespace
	3 & FR1-F & Detect structs with same name & \underline{ 3 } &  3.5  \\
	   &  & Implementation			   	& 2 & 2.5\\
	   &  & Testing - unit				   	& 1 & 1\\
	\addlinespace
	4 & FR2-B & Support display of structs within structs & \underline{ 11 } &  -  \\
	   &  & Implementation			   	& 5 & 2\\
	   &  & Testing - unit				   	& 2 & 1\\
	   &  & Testing - end to end			& 4 & 2\\
	\addlinespace
	5 & FR4-F & Support enumerated named values  & \underline{ 5 } &  -  \\
	   &  & Design				   	& 1 & 0.5\\	   
	   &  & Implementation			   	& 1 & 0.5\\
	   &  & Testing - unit				   	& 1 & -\\
	   &  & Testing - end to end			& 1 & 1.5\\
	   &  & User documentation		   	& 1 & -\\
	\addlinespace
	6 & FR4-G & Support for bit strings & \underline{ 10 } & 11.5 \\
	   &  & Design				   	& 2 & 2\\	   
	   &  & Implementation			   	& 3 & 6\\
	   &  & Testing - unit				   	& 2 & 1\\
	   &  & Testing - end to end			& 2 & 1\\
	   &  & User documentation		   	& 1 & 1.5\\
	\bottomrule
\end{tabularx}
\end{table}

\begin{table}[!ht] \small \center
\caption{Sprint 2 Requirements continued\label{tab:sprint2req2}}
\begin{tabularx}{\textwidth}{l l X c c}
	\toprule
	& & & \multicolumn{2}{c}{Hours} \\
	\cmidrule(r){4-5}
	\# & Req. & Description & Est. & Act. \\
	\midrule
	7 & FR1-E & Support members of type array & \underline{ 7 } & 11 \\
	   &  & Implementation			   	& 3 & 6\\
	   &  & Testing - unit				   	& 1 & 1\\
	   &  & Testing - end to end			& 3 & 4\\
	\addlinespace
	8 & FR4-E & Structs with various trailers & \underline{ 18 } & - \\
	   &  & Design				   	& 3 & 2\\
	   &  & Implementation			   	& 6 & 4\\
	   &  & Testing - unit				   	& 2 & 1\\
	   &  & Testing - end to end			& 5 & -\\
	   &  & User documentation		   	& 2 & -\\
	\addlinespace
	9 & FR4-B & Support for custom Lua configuration & \underline{ 14 } & - \\
	   &  & Design				   	& 2 & -\\
	   &  & Implementation			   	& 5 & -\\
	   &  & Testing - unit				   	& 1 & -\\
	   &  & Testing - end to end			& 4 & -\\
	   &  & User documentation		   	& 2 & -\\
	\addlinespace
	10 & FR4-D & Dissector ID & \underline{ 4 } & - \\
	   &  & Implementation			   	& 1 & 1\\
	   &  & Testing - unit				   	& 1 & 1\\
	   &  & User documentation 			& 2 & -\\
	\addlinespace
	11 & FR5-C & Endian handeling & \underline{ 11 } & - \\
	   &  & Implementation			   	& 5 & -\\
	   &  & Testing - unit				   	& 2 & -\\
	   &  & Testing - end to end			& 6 & -\\
	\addlinespace
	12 & FR6-C & Batch mode; folder support in the CLI & \underline{ 7 } & - \\
	   &  & Implementation			   	& 4 & -\\
	   &  & Testing - unit				   	& 2 & -\\
	   &  & User documentation			& 1 & -\\
	\addlinespace
	13 & FR4-C & Support custom handeling of specific data types & \underline{ 5 } & - \\
	   &  & Implementation			   	& 2 & -\\
	   &  & Testing - unit				   	& 1 & -\\
	   &  & Testing - end to end			& 1 & -\\
	   &  & User documentation			& 1 & -\\
	\midrule
	& & Total: & 108  & - \\
	\bottomrule
\end{tabularx}
\end{table}



\begin{table}[!ht] \small \center
\caption{Sprint 2 Timetable\label{tab:sprint2time}}
\begin{tabularx}{\textwidth}{X c c}
	\toprule
	& \multicolumn{2}{c}{Hours} \\
	\cmidrule(r){2-3}
	Description & Est. & Act. \\
	\midrule
	Design & 8 & -\\
	\addlinespace
	Implementation & 44 & - \\
	\addlinespace
	Testing & 46 & -\\
	\addlinespace
	Documentation & 10 & -\\
	\midrule
	Total: & 108 & - \\
	\bottomrule
\end{tabularx}
\end{table}

%----------------------
\subsection{User Stories}
%----------------------
\line(1,0){360}\\
\textbf{Requirement:} FR1-B: The utility must support members of type enum\\
\textbf{Who:} Administrator\\
\textbf{What:} The user wants the utility to support structs with members of type enum.\\
\textbf{How:} When the cparser module detects an enum member in a struct, the cparser should search in an enum dictionary and the enum member will be mapped to the correct value found in the dictionary. \\
\textbf{Result:} The utility supports members of type enum.\\
\line(1,0){360}\\
\textbf{Requirement:} FR1-C: The utility must support members of type struct\\
\textbf{Who:} Administrator\\
\textbf{What:} The user wants the utility to support structs with members of type struct. \\
\textbf{How:} When the cparser module detects a struct in the AST that is a member of another struct, the cparser searches for its definition in the dictionary of previously detected structs. When it finds it, it looks up the identification number and the size of the inner struct and creates a struct\_field object with that information inside the prototype object corresponding to the outer struct.\\
\textbf{Result:} The utility supports members of type structs.\\
\line(1,0){360}\\
\textbf{Requirement:} FR1-F: The utility should detect structs with the same name, and report it as an error\\
\textbf{Who:} Administrator\\
\textbf{What:} The user wants the utility to report an error if it discovers structs with the same name to avoid unforeseen name collisions.\\
\textbf{How:} When the cparser module traverses the AST to look for structs, it will detect if there are structs with the same name by keeping a database of all structs it has found so far, and the program will crash with an error message.\\
\textbf{Result:} The utility will detect duplicated name of structs.\\
\line(1,0){360}\\
\textbf{Requirement:} The dissector shall be able to support structs within structs\\
\textbf{Who:} Administrator\\
\textbf{What:} The utility should be able to create a Lua dissector that correctly displays structs within structs in Wireshark. \\
\textbf{How:} For each struct definition encountered in cparser, a prototype object is created. This object will include an identifier number used to locate the Lua dissector for that struct. When a struct member is located inside an outer struct. 
The dissector module encodes the identification number and the size for the inner struct into the Lua dissector for the outer struct. The identification number is used to access the dissector for the inner struct when the outer struct dissector is used. The outer struct dissector uses the size of the inner struct to know how much of the network package to forward to the inner struct dissector.
The size and identification number of the inner struct will be available in the struct field corresponding to the inner struct inside the protocol object corresponding to the outer struct.\\
\textbf{Result:} The dissector module supports nested structs\\
\line(1,0){360}\\
\textbf{Requirement:} FR4-F: Configuration must support integer members which represent an enumerated named value\\
\textbf{Who:} Administrator\\
\textbf{What:} The user wants to specify integer members, represented by an enumerated named value, in a configuration file.\\
\textbf{How:} The config module should read config files provided to the command line interface, and find any rules regarding enumerated integer values. The rules are used by the cparser when it translates struct definitions to Protocol, and makes the cparser create EnumFields instead of normal Fields for the specified members.\\
\textbf{Result:} Enum members can be specified in the configuration.\\
\line(1,0){360}\\
\textbf{User doc:} FR4-F: User documentation for writing configuration for integer members which represent an enumerated named value.\\
\textbf{Who:} Administrator\\
\textbf{What:} The user should be able to educate himself of how to give CSjark the necessary information to get integer values mapped to names in the generated dissector.\\
\textbf{How:} The user opens the user documentation and finds the section about configuration. From here he locates the sub section about enumerated names integer values. This section gives a good description of how to write such configuration, and the user is able to implement his desired configuration after reading trough once and looking at provided examples.\\
\textbf{Result:} The user is now able to use the enumerated named value functionality.\\
\line(1,0){360}\\
\textbf{Requirement:} FR4-G: Configuration must support members which are bit strings\\
\textbf{Who:} Administrator\\
\textbf{What:} The user wants to specify members that represent bit strings in the configuration.\\
\textbf{How:} The config module should read config files provided to the command line interface, and find any rules regarding bit strings. The rules are used by the cparser when it translates struct definitions to Protocol and BitField instances found in the dissector module.\\
\textbf{Result:} Bit string members can be specified in the configuration.\\
\line(1,0){360}\\
\textbf{User doc:} FR4-G: User documentation for writing configuration for integer members which are bit strings.\\
\textbf{Who:} Administrator\\
\textbf{What:} The user should be able to educate himself of how to give CSjark the necessary information to get integer values mapped to bit string in the generated dissector.\\
\textbf{How:} The user opens the user documentation and finds the section about configuration. From here he locates the sub section about bit string integer values. This section gives a good description of how to write such configuration, and the user is able to implement his desired configuration after reading through once and looking at provided examples.\\
\textbf{Result:} The user is now able to configure CSjark to generate dissector that recognises and formats bit strings correctly.\\
\line(1,0){360}\\
\textbf{Requirement:} FR1-E: The utility must support members of type array\\
\textbf{Who:} Administrator\\
\textbf{What:} The user wants the utility to support structs with members of type array.\\
\textbf{How:} When the cparser module find an array declaration, it recursively traverses the tree until till it encounters the bottom of the declaration to discover the size of the array. The parser module creates an instance of an array field with the size and type of the array. From the array field the dissector module generates a dissector which has a sub tree for each level of the array.\\
\textbf{Result:} The utility support array members in structs.\\
\line(1,0){360}\\
\textbf{Requirement:} FR4-E: Configuration must support various trailers (other registered protocol)\\
\textbf{Who:} Administrator\\ 
\textbf{What:} The user wants to specify trailers to a C header file in the configuration.\\
\textbf{How:} The config module should read config files provided to the command line interface, and find any rules regarding trailers. A member in a struct will say how many packets of other protocols that follows the header. In the config-file it is specified which member contains this number, and what type of protocol the packet(s) belong to. When the dissector module generates a struct containing a trailer, the correct dissector for the trailer packet(s) will be called for the rest of the buffer.\\
\textbf{Result:} The utility can handle trailer packets following the header, specified in the configuration.\\
\line(1,0){360}\\
\textbf{User doc:} FR4-E: User documentation for how to specify trailers (other registered protocol)\\
\textbf{Who:} Administrator\\
\textbf{What:} The user should be able to find out how to specify trailers to a header struct by reading the user documentation.\\
\textbf{How:} The user opens the user documentation and finds the section about configuration. From here he locates the sub section about trailers. This section gives a good description of how to write such configuration for different types of trailers and provides sufficient examples, so that it is  clear to the user how to write the configuration he needs after reading the section.\\
\textbf{Result:} The user is now able to utilise the trailer feature of CSjark.\\
\line(1,0){360}\\
\textbf{Requirement:} FR4-B: Configuration must support custom Lua files for specific protocols\\
\textbf{Who:} Administrator\\
\textbf{What:} The user wants to specify custom Lua files in the configuration, that are to be used in complex cases where our utility is unable to generate a dissector for the C header.\\
\textbf{How:} The config module should read config files provided to the command line interface, and find any rules regarding the use of custom Lua files. When such a rule is found the dissector module will use the Lua code found in the file(s) in addition to its own generated Lua code.
This us done by reading the custom Lua file(s) and writing the content to the relevant parts of the dissector.\\
\textbf{Result:} The use of custom Lua files can be specified in the configuration.\\
\line(1,0){360}\\
\textbf{Requirement:} FR4-D: Configuration must support specifying the ID of dissectors \\
\textbf{Who:} Administrator\\
\textbf{What:} The user wants to specify the ID of a dissector in a configuration file.\\
\textbf{How:} When the cparser finds a struct in the abstract syntax tree it looks for a configuration file for the struct. If a config-file is found, the ID of the dissector is mapped to the ID given in the config-file when generating the dissector.\\
\textbf{Result:} The configuration supports specifying the ID of dissectors.\\
\line(1,0){360}\\
\textbf{Requirement:} FR5-C: Generate dissectors which support both little and big endian platforms\\
\textbf{Who:} Administrator\\
\textbf{What:} The user wants the utility to produce dissectors that can be used on both little and big endian platforms.\\
\textbf{How:} The user will specify platforms he is using in a configuration file by adding a message flag and endian pair. When the dissector for a struct is beeng generated, the dissector module in CSjark will encode a flag to endian dictionary inside the Lua dissector file. This dictionary will be used to look up the endian for a message given its flag. If no endian is found in the dictionary, it will use a default value.\\
\textbf{Result:} The dissectors are now able to support messages from platforms with different endian.\\
\line(1,0){360}\\
\textbf{Requirement:} FR6-C: Command line shall support batch processing of C header and configuration files\\
\textbf{Who:} Administrator\\
\textbf{What:} The user wants to set up the program to run automatically, so that the program creates dissectors from the C header and configuration file(s) that are specified.\\
\textbf{How:} When the user feeds the command line with an input argument, header or configuration, the utility shall check if the input is a single file or a directory (folder). If it is a file, parse it. If it is a folder, retrieve all files in that folder and add them to a list, this list will be sent to the parser and all the files will be parsed one after another. If there is a directory within a directory, that should be included, and they will be traversed recursively. This way we can start in a root folder and include all files, independent of the depth. The batch mode shall only include files with the extension .h (a header file) or .yml (config file), which are the files that are going to be parsed as input.\\
\textbf{Result:} Now it shall be possible to feed the utility with folders to make dissectors of all the headers found, also called batch mode.\\
\line(1,0){360}\\	


%----------------------
\section{System Design}
%----------------------
For sprint 2 the team decided to refactor some of the code in order to make it easier to read and to split the functionalities of the utility in such a way that it reduces coupling within the system.Some new functionality was also added on the parser side in order to get the utility to recognize the datatypes mentioned in the sprint 2 backlog. Other than that, there were no other changes or additions made to the design during sprint 2.

\subsection{Utility}
%--------------------
\autoref{fig:sp2:class} shows the class diagram the team made for sprint 2. The main differences from sprint 1 are the additions of new classes, extending the functionality of the utility so that the utility can handle more complex header files than it could before. The developers also generalized some of the modules and used inheritance to support the re-use of code 
\begin{figure}[!htb]
	\center
	\includegraphics[width=\textwidth]{./sprints/img/class_diagram_s2}
	\caption{Class Diagram\label{fig:sp2:class}}
\end{figure}



%----------------------
\section{Implementation}
%----------------------

In the previous sprint we focused on creating a naive implementation of the 
utility. In this sprint the focus was on implementing data types for the 
C programming language and making it possible to configure more options on how 
the dissector will function. This section will cover the requirements 
implemented, how they were implemented and what the ''output'' looks like.

\subsection{Support Members of Type enum}
%----------------------
\label{sec:supportenum}
Enum is a type declaration in C, which specifies enumeration constants.  Enum 
is supported because it is a basic datatype in the C language. 
\autoref{code:cenum} shows an example of an enum in a C-header file. The 
Wireshark dissector will display the named value, making it 
easier to read, an example is shown in \autoref{fig:wscenum}. The red 
rectangle shows the enumerated named value.

\begin{figure}[ht]
	\center
	\includegraphics[width=\textwidth]{./sprints/img/wireshark_cenum}
	\caption{Enumeration in Wireshark\label{fig:wscenum}}
\end{figure}

\lstset{language=C,caption={Enum support},label=code:cenum}
\lstinputlisting[language=C]{./sprints/code/cenum_test.h}

\subsection{Support Members of Type Struct}
%----------------------
Structs are an important part of the C language, a struct declaration consists 
of a group of different fields, these fields can have any type, also struct. 
This was therefore an important requirement to implement. An example is shown 
in \autoref{code:structmember}.

\lstset{language=C,caption={Struct support},label=code:structmember}
\lstinputlisting[language=C]{./sprints/code/struct_member.h}

\subsection{Detect Structs with Same Name}
%----------------------
Two structs can have the same name, and therefore we needed a way of detecting it. 
If the parser finds two structs with the same name, an exception is 
raised, and the generation of the dissector is terminated.

\subsection{Support display of structs within structs}
%----------------------
The utility is able to display structs within a struct in Wireshark, the 
member will be visible, and the struct will be in a subtree that can be 
expanded. \autoref{fig:wsstructstruct} is a screenshot of this dissector in 
Wireshark.

\begin{figure}[ht]
	\center
	\includegraphics[width=\textwidth]{./sprints/img/wireshark_structwithstruct}
	\caption{Structs in Wireshark\label{fig:wsstructstruct}}
\end{figure}

\subsection{Support Enumerated Named Values}
%----------------------
In C there are two ways to do enumerations, the first option was explained in 
\autoref{sec:supportenum}, the other way is to use \#define which is shown in 
\autoref{code:defenum}. The advantage of using \#define is that the values 
can be generated. Since this cannot be understood by the parser, it can be 
generated directly from the header file, so it have to be supported by 
configuration. \autoref{code:enumconf}. The Lua-dissector will display the 
enum in the same way as in \autoref{sec:supportenum}.

\lstset{language=C,caption={Enumerated named values},label=code:defenum}
\lstinputlisting[language=C]{./sprints/code/def_enum.h}

\lstset{language=C,caption={Enumerated named values config},label=code:enumconf}
\lstinputlisting[language=C]{./sprints/code/def_enum.yml}

\subsection{Support for Bit Strings}
%----------------------
All bits in a basic data type can represent different values. An integer is 
represented by 4 bytes(32 bits), each of these bits can for example represent 
32 ''true/false' values. Our utility support configuration of these bits. Bits 
can be in groups, so they can represent more than two values. 
\autoref{code:bitstring} shows how bit string can be configured. 
\autoref{fig:wsbitstring} shows an example of how bit strings are displayed in 
Wireshark. Each group of bits are masked, so it is easier to see the values. 
The values are also named, if they are configured.

\begin{figure}[ht]
	\center
	\includegraphics[width=\textwidth]{./sprints/img/wireshark_bitstring}
	\caption{Bit string in Wireshark\label{fig:wsbitstring}}
\end{figure}

\lstset{language=C,caption={Bitstring configuration},label=code:bitstring}
\lstinputlisting[language=C]{./sprints/code/bitstring.yml}

\subsection{Support Members of Type Array}
%----------------------
Csjark supports header-files with arrays, and is able to display them in 
Wireshark with the Lua-dissector. Csjark supports arrays of all data types 
implemented so far. The Wireshark dissector can display multidimensional 
arrays, and will create a new subtree for each dimension.  A representation of 
arrays in wireshark is displayed in \autoref{fig:wsarray}.

\begin{figure}[ht]
	\center
	\includegraphics[width=\textwidth]{./sprints/img/wireshark_array}
	\caption{Arrays in Wireshark\label{fig:wsarray}}
\end{figure}

\subsection{Struct with Various Trailers}
%----------------------
The utility is able to support struct that has various trailers. Trailers are
data that follows a struct, this can be any kind of data. The utility is able to configure these data.
TODO: Not finished(add example + screenshot)

\subsection{Custom Lua Configuration}
%----------------------
Csjark can support custom Lua configuration, by including Lua-scripts from a file specified in the configuration file. This is implemented so that the users of the utility can include parts for the dissector, which our utility is not able to generate. The Lua-script can also include dissector for trailers, which are not from a struct.
TODO: Not finished(add example + screenshot)

\subsection{Dissector ID}
%----------------------
All struct-packets that Wireshark captures, has a header, one of the fields in 
the header is the message id. This id is used to load the the correct 
dissector when a packet is captured. Each dissector should have a unique id, 
to avoid possible conflicts. This functionallity is implemented and the 
message id must be specified in the configuration file, \autoref{code:msgid} 
is an example of how this is done.

\lstset{language=C,caption={Dissector ID config},label=code:msgid}
\lstinputlisting[language=C]{./sprints/code/messageid.yml}

\subsection{Endian Handling}
%----------------------
Endian handling is postponed to the next sprint, because it is a platform 
specific problem, and should be implemented together with platform support.

\subsection{Folder Support in the CLI}
%----------------------
Folder support in the CLI\footnote{Command-line Interface} has been 
implemented, so it is possible to generate Lua-scripts for all structs stored 
in a given folder. At the moment, all dissectors will be regenerated. 
Functionality to only generate modified or new header-files will be added in 
the next sprint. \autoref{fig:csjarkfolder} is an example usage of CSjark where
the command first shows the usage of CSjark, and the second command 
generates dissectors from the folder ''header/'' and configurations from ''etc/''.

\begin{figure}[ht]
	\center
	\includegraphics[width=\textwidth]{./sprints/img/csjark_folder}
	\caption{Arrays in Wireshark\label{fig:csjarkfolder}}
\end{figure}

\subsection{Support Custom Handling of Specified Data Types}
%----------------------
The utility supports custom handling of different data types, this includes 
functionality to support  time\_t and nstime\_t. All basic data types and 
struct members can be configured to be handled in a special way. 
\autoref{code:customstruct} show an example of a struct with four members, two 
of them are time fields, and the last two is a BOOL and an integer to be 
handled in a custom way. This struct is configured in 
\autoref{code:customconfig}, in the config the two time fields are configured 
to be respectively absolute time and relative time, and the BOOL type to have 
a size of four bytes. The struct member ''all' is configured with an enumerated 
value, and will be visible as a hex-value. \autoref{fig:customdatatype} is a 
screenshot of the struct in Wireshark.

\begin{figure}[ht]
	\center
	\includegraphics[width=\textwidth]{./sprints/img/wireshark_custom}
	\caption{Custom handling of Data Typesk\label{fig:customdatatype}}
\end{figure}

\lstset{language=C,caption={Struct for custom handling},label=code:customstruct}
\lstinputlisting[language=C]{./sprints/code/customfield.h}

\lstset{language=C,caption={Config for custom handling},label=code:customconfig}
\lstinputlisting[language=C]{./sprints/code/customfield.yml}

\subsection{Typedef Support}
%----------------------
Csjark is supporting the keyword typedef, which is a facility to create new 
data types names. \autoref{code:typedef} shows examples of typedef's that 
csjark supports.

\lstset{language=C,caption={Typedef example},label=code:typedef}
\lstinputlisting[language=C]{./sprints/code/typedef.h}

%-----------------------
\section{Sprint Testing}
%-----------------------
This section introduces the tests preformed during the sprint and their results. For sprint 2 it was also decided that the larger unit tests should also be documented and added to the test documents.

%subsection{Tests}
During the sprint the team executed a total of 6 tests with names as seen below. Tests executed:
\begin{itemize}
	\item TID08 - Supporting members of type enum \autoref{tab:sp2TID08}
	\item TID09 - Supporting members of type array  \autoref{tab:sp2TID09}
	\item TID10 - Supporting the display of structs within structs  \autoref{tab:sp2TID10}
	\item TID11 - Supporting enumerated named values  \autoref{tab:sp2TID11}
	\item TID12 - Supporting bit strings  \autoref{tab:sp2TID12}
	\item TID13 - Supporting structs with various trailers \autoref{tab:sp2TID13}
\end{itemize}

\subsection{Test Results}
%----------------------------
\begin{table}[!htb] \footnotesize \center
\caption{Recognizing Supporting enums \label{tab:sp2TID08}}
\begin{tabular}{l l}
	\toprule
	Header & Description \\
	\midrule
	Description &  Supporting members of type enum  \\
	Tester & Lars Solvoll Tønder \\
	Date & 15.10.2011 \\
	Result & Success\\
	\bottomrule
\end{tabular}
\end{table}

\begin{table}[!htb] \footnotesize \center
\caption{Recognizing Supporting arrays \label{tab:sp2TID09}}
\begin{tabular}{l l}
	\toprule
	Header & Description \\
	\midrule
	Description &  Supporting members of type array   \\
	Tester & Lars Solvoll Tønder \\
	Date & 15.10.2011 \\
	Result & Success\\
	\bottomrule
\end{tabular}
\end{table}

\begin{table}[!htb] \footnotesize \center
\caption{Supporting the display of sctructs within structs \label{tab:sp2TID09}}
\begin{tabular}{l l}
	\toprule
	Header & Description \\
	\midrule
	Description &  Supporting the display of sctructs within structs \\
	Tester & Lars Solvoll Tønder \\
	Date & 17.10.2011 \\
	Result & Success\\
	\bottomrule
\end{tabular}
\end{table}

\begin{table}[!htb] \footnotesize \center
\caption{Supporting the display of sctructs within structs \label{tab:sp2TID10}}
\begin{tabular}{l l}
	\toprule
	Header & Description \\
	\midrule
	Description &  Supporting the display of sctructs within structs \\
	Tester & Lars Solvoll Tønder \\
	Date & 17.10.2011 \\
	Result & Success. Wireshark crashes when trying to change packets and sometimes when loading the pcap file associated with this test. This is assumed to be a wireshark bug\\
	\bottomrule
\end{tabular}
\end{table}

\begin{table}[!htb] \footnotesize \center
\caption{Supporting enumerated name values \label{tab:sp2TID11}}
\begin{tabular}{l l}
	\toprule
	Header & Description \\
	\midrule
	Description &  Supporting enumerated name values \\
	Tester & Lars Solvoll Tønder \\
	Date & 17.10.2011 \\
	Result & Success\\
	\bottomrule
\end{tabular}
\end{table}


\begin{table}[!htb] \footnotesize \center
\caption{ Supporting bit strings \label{tab:sp2TID12}}
\begin{tabular}{l l}
	\toprule
	Header & Description \\
	\midrule
	Description & Supporting bit strings \\
	Tester & Lars Solvoll Tønder \\
	Date & 17.10.2011 \\
	Result & Success\\
	\bottomrule
\end{tabular}
\end{table}

\begin{table}[!htb] \footnotesize \center
\caption{Supporting structs with various trailers \label{tab:sp2TID13}}
\begin{tabular}{l l}
	\toprule
	Header & Description \\
	\midrule
	Description & Supporting structs with various trailers \\
	Tester & FILL IN YOUR NAME HERE \\
	Date & FILL IN THE DATE YOU RAN THE TEST HERE \\
	Result & FILL IN THE RESULT HERE\\
	\bottomrule
\end{tabular}
\end{table}

\begin{table}[!htb] \footnotesize \center
\caption{unit test of the functionality in sprint 2\label{tab:sp2TID14}}
\begin{tabular}{l l}
	\toprule
	Header & Description \\
	\midrule
	Description & unit test covering all of the functionality implemented in sprint 2 \\
	Tester & FILL IN YOUR NAME HERE \\
	Date & FILL IN THE DATE YOU RAN THE TEST HERE \\
	Result & FILL IN THE RESULT HERE\\
	\bottomrule
\end{tabular}
\end{table}

\subsection{Test Evaluation}
%-------------------------------
For the second sprint the developers focused a lot more on testing during implementation. The team also decided that the testers should check how much of the code was covered in the unit tests. This made the group focus more on making proper unit tests that tests as much functionality as possible This had a very positive effect on the tests ran at the end of the sprint where not a single test failed, except for one test which ended up exposing a bug in Wireshark

\subsubsection{Test Coverage}
This section introduces the amount of code covered by our unit tests and how it relates to the test coverage from the previous sprints.

WHEN THE BLACK BOX TEST IS DONE, MAKE A GRAPH OF THE CODE COVERAGE AND PUT IT HERE

 


%--------------------------
\section{Customer Feedback}
%--------------------------


%--------------------------
\section{Sprint Evaluation}
%--------------------------


