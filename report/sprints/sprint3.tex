%=================
\chapter{Sprint 3}
%=================


%------------------------
\section{Sprint Planning}
%------------------------
For the third sprint we intend to implement the remanding requirements in the product backlog. We feel that the first and second sprint has resulted in a satisfying utility, but it is still missing important functionality.

After two sprint iterations, we are still trying to improve our approach to Scrum. Each sprint results in new ideas and better ways to do the process, and in this sprint we want everything to be correct and in the right order.\\
\\
There will be two major changes this sprint:
\begin {itemize}
\item We will have a complete planning meeting. The meeting should result in a good planning document, user stories for all the requirements, complete set of work items in the sprint backlog and a early understanding of the design. This approach will be differently from earlier sprints, where user stories was written in parallel with implementation. The user story should now be in place before the implementation, and the implementation should be based on the user story. This will make documenting the process easier, and will in turn give the advisors more documentation of what we are doing. Then we can receive valuable feedback from them.

\item In the sprint backlog we will have work items for every task that needs to be done throughout the sprint, including writing minutes, doing documentation, implementation and so on.  Assignment of responsibilities for items in the backlog should not be done at the planning meeting, we rather only give responsibility for one item for each team member at a time. The rest of the items will be unassigned. At each stand-up meeting we pick a task and must be done before the next meeting. This will ensure efficiency and the work done by others are easier to check and revise. It will give us a better work balance, as no team member can gap over too many tasks and leave none for the others.
\end{itemize}
We think that these changes will improve our work efficiency, and make sprint 3 the best one so far.


\subsection{Duration}
%-----------------------

The sprint started with the planning meeting the 19th of October and our work started the following day. The sprint duration is 14 days, and will end the 1st of November with a review meeting. 


\subsection{Sprint Goal}
%-----------------------
For the third sprint the team will update CSjark to version 0.3 which will extend the utility so that it contains the complete functionality requested by the customer at this phase of the project. In this sprint we will pick all of the current requirements from the product backlog as all of the underlying functionality needed for them are already in place from the previous sprints. This means that we will also aim to create a draft of the final design of the system during the sprint.

The most important function that is going to be implemented in this sprint is being able to display packets from different originating platforms properly. This will be implemented by having every packet contain a flag specifying their originating platform, and by having our dissectors use this flag value to influence how it handles the data in the packet.

\subsection{Back Log}
%--------------------

\subsection{User Stories}
%--------------------

This section lists the user stories for the second sprint. They complement
the work items in the TODO. As we are developing a very technical utility we
have written user stories with an implementation level of abstraction. These
user stories represent how we intend to add the functionality of the each
requirement to the utility. This section is subject to change throughout the
sprint, as we do not know all the details yet.\\

\begin{table}[htbp] \footnotesize \center
\caption{User stories - Sprint 3 part 1\label{tab:req:stories7}}
\noindent\makebox[\textwidth]{%
\begin{tabularx}{1.2\textwidth}{l X}
	\toprule
	Header & Value \\
	\midrule
	ID & US26 \\
	Requirement & FR1-D: The utility must support members of type union \\
	Who & Administrator \\
	What & The user wants to generate dissectors which contain structs with unions as members. \\
	How & When the user feeds the utility with a header containing a union, the cparser module should parse the union and its members to 			find the total size of the union (which equals the size of the largest member), and then create an instance of UnionField from the 				dissector module representing the union and its member\\
	Result & The utility support union members in structs. \\
	\midrule
	ID & US27 \\
	Requirements & FR2-A\textit{Addition:} Display a wildcard type for valid C types that Wireshark has no support 	for. \\
	Who & Administrator \\
	What & The user should be able to give the tool a struct with a valid C-type even if Wireshark does not have a way to display that type  			in a natural way. The dissector should the just display the name of the type, the name of the member and the hex value from the packet. \\
	How & The parser module will recognise if a type it encounters are supported in Wireshark or not. If it is not supported, it will add a wildcard 		field to the prototype object representing the enclosing struct. \\
	Result & The user will be able to both run the utility and get some information from the dissector even if the type 	used is not 					supported by Wireshark. \\
	\midrule
	ID & US28 \\
	Requirements & FR2-C: Filter and search on attributes (important to have descriptive abbreviations) \\
	Who & Developer \\
	What & The amount of data captured can be big. After the packets have been dissected, they are presented in Wireshark. The user will 			have a hard time finding attributes by manual seeking. The built-in search and filter functionality needs to be supported to accommodate the 	user. \\
	How & The functionality is already in Wireshark. To utilize it, an abbreviation field must be provided to Wireshark. This abbreviation field will 			be in the dissector module and is included in the dissector generated by the utility. When Wireshark runs the dissector, all abbreviations are 			collected which will make it possible to filter and search attributes. \\
	Result & The user will be able to search and filter by attributes. \\
	\midrule
	ID & US29 \\
	Requirements & FR5-A: Flags must be specified in configuration for each platform \\
	Who & Administrator \\
	What & The user wants to generate dissectors which are different depending on platform. \\
	How & To be able to create dissectors which are different depending on the originating platform the user needs to specify in the 				configuration which platforms he wants to support. The config module should accept such configuration and store it so other modules
	can use it. \\ 
	Result & The user can specify what platform he is using by setting a flag in the configuration. \\
	\midrule
	ID & US30 \\
	Requirements & FR5-B: Generate dissectors with correct alignment depending on platform.\\
	Who & Administrator \\
	What & The user wants to generate dissectors which are different depending on platform. \\
	How & The dissector module will use the configured flags from the config module to modify the generated lua dissectors so that they have 			the right memory structure alignment and endianness. The dissector module shall have a function which calculates the offset for each field 			to align it, and functions which creates fields for specific endianness. \\
	Result & Dissectors can be created with platform specific memory structure alignment. \\
	\bottomrule
\end{tabularx}}
\end{table}

\begin{table}[htbp] \footnotesize \center
\caption{User stories - Sprint 3 part 2\label{tab:req:stories8}}
\noindent\makebox[\textwidth]{%
\begin{tabularx}{1.2\textwidth}{l X}
	\toprule
	Header & Value \\
	\midrule
	ID & US31 \\
	Requirement & FR5-C: Generate dissectors which support both little and big endian platforms \\
	Who & Administrator \\
	What & The user wants dissectors which handle both big and little endian encoding. \\
	How & The dissector module will need to create different lua code for big and little endian, when adding nodes to the Wireshark tree and 			when calling other dissectors. The dissector module shall have functionality which generates lua code depending on endianness, and the 			different Field classes must use this function when adding nodes to the Wireshark tree. \\
	Result & Dissectors can be created with platform specific endian. \\
	\midrule
	ID & US32 \\
	Requirements & FR5-D: Generate dissectors which support different sizes depending on platforms \\
	Who & Administrator \\
	What &  The user wants to generate dissectors for struct where members size depend on the originating platform. \\
	How & When the user feeds the utility a header file and a config file with a set of platform he wants dissectors for, the config module will 			create a new header files with C preprocessor directives for each platform. These files should define platform-specific macros which 				emulates parsing on the specific platform. The dissector module then create different dissectors for each message on each platform, and a 			mapping is added inside the master lua file which maps message id and platform to the correct dissector. \\
	Result & Dissectors can be created with platform specific sizes of members.\\
	\midrule
	ID & US33 \\
	Requirements & FR3-C: Support for configuring a platform with a platform specific macro like WIN32, \_WIN64, \_\_sparc to be able to  			support different struct definitions for different platforms. \\
	Who & Administrator \\
	What & The user wants to be able to configure the utility to make dissectors that support structs that is defined differently on different 			platforms via platform specific macros like WIN32, \_WIN64, \_\_sparc. \\
	How & The user specify the macro associated with a platform together with the platform definition configuration. The utility then make a 			auxiliary header file for each platform configuration with the specified macro definition. These header also undefines  These header are 			forwarded to the parser module, which uses them to generate one dissector for each platform for each struct. All dissectors dissecting the 			same structs are stored in the same file, but are added to a platform specific dissector table. \\
	Result & The generated lua files corresponding to structs now includes one dissector for each platform defined in the configuration file. \\
	\midrule
	ID & US34 \\
	User doc & FR4-C: User documentation for configurating custom handling of specific types. \\
	Who & Administrator \\
	What & The user should be able to find out how to specify custom handling for a specific type by reading the user documentation. \\
	How &	 The user opens the user documentation and finds the section about configuration. From here he locates the sub section about 			custom type handling. This section gives a good description of how to write such configuration and what kind of configuration that could be 			done. There should also be some examples to clarify the description. After reading the section, the user has a good idea of how to do the 			desired custom handling. \\ 
	Result & The user is able to use custom handling of specific types. \\
	\midrule
	ID & US35 \\
	Requirements & FR4-D modified: Configuration must support specifying the ID of dissectors \\
	Who & Administrator \\
	What & The user wants to specify the ID of a dissector in a configuration file. The dissectors should not be given any ID if it has not been 			specifically configured. \\
	How & When the cparser finds a struct in the abstract syntax tree it looks for a configuration file for the struct. If a config-file is found, the 			ID of the prototype field representing the dissector will be mapped to the ID given in the config-file.  If it is not found, the ID will be sat to 			NONE. \\
	Result & The configuration supports specifying the ID of dissectors. \\
	\bottomrule
	ID & US35 \\
	Requirements & FR4-D modified: Configuration must support specifying the ID of dissectors \\
	Who & Administrator \\
	What & The user wants to specify the ID of a dissector in a configuration file. The dissectors should not be given any ID if it has not been 			specifically configured. \\
	How & When the cparser finds a struct in the abstract syntax tree it looks for a configuration file for the struct. If a config-file is found, the 			ID of the prototype field representing the dissector will be mapped to the ID given in the config-file.  If it is not found, the ID will be sat to 			NONE. \\
	Result & The configuration supports specifying the ID of dissectors. \\
	\midrule
	ID & US36\\
	Who &  Developer\\
	What & The user wants to be able to specify that some integers should be interpreted as a string of bits where every bit has a different flag-name\\
	How & The config module should read config files provided to the command line interface, and find any rules regarding interpreting members that are supposed to be represented as bitstrings. These rules are then used by the cparser when it tralslates struct definitions to Protocol and Field instances found in the dissector module.\\
	Result & It is possible to specify that member values in structs are to be displayed as bitstrings in wireshark.\\
	\bottomrule
\end{tabularx}}
\end{table}

\begin{table}[htbp] \footnotesize \center
\caption{User stories - Sprint 3 part 3\label{tab:req:stories9}}
\noindent\makebox[\textwidth]{%
\begin{tabularx}{1.2\textwidth}{l X}
	\toprule
	Header & Value \\
	\midrule
	ID & US36 \\
	User doc & FR5 User documentation for how to add or remove support for a platform in the dissectors generated from the utilities. \\
	Who & Administrator \\
	What & The user should be able to find out how to add or remove support for a platform in the dissectors by reading the user					documentation. \\
	How & The user opens the user documentation and finds the section about configuration. From here he locates the sub section about 			platform support. This section gives a good description of how to add or remove support for a platform in the configuration, so that the user 	understands how to do this after reading the section. \\
	Result & The user is now able to configure the utility to add or remove platform support from the generated dissectors. \\
	\midrule
	ID & US37 \\
	User doc & FR5 User documentation for what platform that the utility support. \\
	Who & Administrator \\
	What & The user should be able to find out what platforms he can add support for in the custom dissector files. \\
	How & The user opens the user documentation and finds the section about configuration. From here he locates the sub section about 			platform support. This section gives a list of currently supported platforms by the utility. It should also have some information of where to 			find the documentation that describes how to add support for more platforms. \\
	Result & The user is now able to look up what platforms he can get the dissectors to support. \\
	\midrule
	ID & US38 \\
	Requirements & FR6-D The utility should not regenerate dissectors within a single run. \\
	Who & Administrator \\
	What & The user should be able to specify folder that includes both a standalone header file  with a struct definitions and another header 			file that includes the first header. The utility will only generate the dissector once for the struct inside the first header. \\
	How & For each struct encountered, the utility will check the table of generated dissectors to see if there is an existing dissector generated 			for the struct name. It will only generate a new dissector if the table of dissector is empty for that name. \\
	Result & The utility will run faster as a result of not needing to regenerate dissectors. \\
	\midrule
	ID & US39 \\
	Requirements & Handle Lua reserved definition names \\
	Who & Administrator \\
	What & The C structs could contain members with names that are reserved by Lua. The dissector module need to avoid creating Lua 				variables with such names.  \\
	How &	 The dissector module has a method called create\_lua\_var. This method will ensure that variable names are valid, by comparing the 			variable names to a list of Lua reserved keywords, and if there is a match we need to add an underscore in front of the variable name. \\ 
	Result & The utility can handle C header files that contain Lua reserved definition names. \\
	\bottomrule
\end{tabularx}}
\end{table}

%----------------------
\section{System Design}
%----------------------


%-----------------------
\section{Implementation}
%-----------------------


%-----------------------
\section{Sprint Testing}
%-----------------------


%--------------------------
\section{Customer Feedback}
%--------------------------


%--------------------------
\section{Sprint Evaluation}
%--------------------------


