%=================
\chapter{Sprint 4}
%=================
This chapter contains the description of the work done in sprint 4. The 
chapter is diveded into sprint planning in \autoref{sec:sp4planning}, design 
done during the sprint in \autoref{sec:sp4design}, the implementation in 
\autoref{sec:sp4impl}, the result of the sprint testing in 
\autoref{sec:sp4test}, feedback the customer gave us during the sprint in 
\autoref{sec:sp4feedback} and evaluation of the sprint in 
\autoref{sec:sp4eval}.

%------------------------
\section{Sprint Planning}
%------------------------
\label{sec:sp4planning}
The fourth sprint will be the last iteration of this project. Because it is very important to make the \gls{utility} work properly on Thales' source code, most of the sprint work hours will be used on testing and bugfixing. Now the \gls{utility} fails on most of the \glspl{struct}; the customer tried to generate \glspl{dissector} for 580 \glspl{struct}, and only 4 of them succeeded. It will probably just take some small tweaks to make it work for most of the \glspl{struct}.

We know that some of our earlier implementation do not work as intended or are incomplete. The customer has given us feedback on the fulfilled requirements, and pointed out what needs to be improved. These are important work items that were added to this sprint backlog \ref{sp4:backlog}. In addition, we received new requirements that the customer would like us to implement, as they add some convenient functionalities for them. For the optional requirements that we might not have time to implement, we have agreed to write a specification on how to implement them. 

There will not be another sprint after this one, so we can not postpone any work items. Because of this, we had to make some of the new requirements from the customer optional, and also told he customer that we will probably not be able complete all their desires. We are trying to improve from the last sprint, and will therefore not add more tasks than we think we can complete this sprint. This sprint we plan to use close to 350 hours, but it is still likely that we will use more and are prepared for that. There will certainly pop up new tasks and unforeseen bugs that we have to fix.

\subsection{Duration}
%-----------------------
The sprint started with the planning meeting the 2nd of November and our work started the following day. The sprint duration is 14 days, and will end on the 15th of November with a review meeting. 

\subsection{Sprint Goal}
%-----------------------
The goal of this sprint will be to focus on fixing and implementing functions that the customer will need to use the \gls{utility} on their source code. The most important thing to focus on in the beginning of the sprint will be to implement support for \#pragma directives and support for including \gls{header}-files that are not included by the \gls{preprocessor}. This is important, as it will make it possible for the customer to fully test the \gls{utility}.

Since the deadline of the project is 24th November, there will also be a focus on preparing a presentation and improving the report for the final delivery. The team are also going to hold a presentation for the customer's developers on the 17th of November, and it is important to also focus on this presentation.

\subsection{Back Log}
%--------------------
This section contains the sprint backlog \ref{tab:sprint4req} and the timetable for the sprint Table \ref{tab:sprint4time}.  

\begin{table}[!htb] \small \center
\caption{Sprint 4 Requirement Work Items \label{tab:sprint4req}}
\begin{tabularx}{\textwidth}{l X c c}
	\toprule
	& & \multicolumn{2}{c}{Hours} \\
	\cmidrule(r){3-4}
	User story & Req. and Description & Est. & Act. \\
	\midrule
	\textbf{Impl.} &  & \textbf{47} & \textbf{-} \\
	\hyperref[tab:req:stories13]{US57} & FR2-E: guess \gls{dissector} from \gls{packet} size & 5 & - \\
 	\hyperref[tab:req:stories10]{US41} & FR3-A mod: support \gls{include} of system \glspl{header} &  8  & - \\
	\hyperref[tab:req:stories10]{US42} & FR3-D mod: ignore \#pragma directives & 2 & - \\
	\hyperref[tab:req:stories10]{US43} & FR3-E: find include dependencies which are not explicitly set & 16  & - \\
	\hyperref[tab:req:stories11]{US48} & FR4-B mod: custom \Gls{lua} files support for offset and value inside a .cnf file & 4 & - \\
	\hyperref[tab:req:stories12]{US50} & FR4-D mod: multiple message ID's for one \gls{dissector} & 2 & - \\
	\hyperref[tab:req:stories12]{US53} & FR4-H: autogenerate configuration files for \glspl{struct} without a config file & 1  & - \\
	\hyperref[tab:req:stories12]{US52} & FR4-I: allow configuration of size for unknown \glspl{struct} & 4 & - \\
	\hyperref[tab:req:stories10]{US44} & FR6-E: support \Gls{c} macros from \gls{cli} & 1 & - \\
	\hyperref[tab:req:stories12]{US55} & FR6-F: only generate \glspl{dissector} for \glspl{struct} with valid a id and their dependencies & 4 & - \\
	\addlinespace
	\textbf{Fixes} &  & \textbf{35} & \textbf{-} \\
	& TheFIX: Be able to process customer's files & 12 & - \\
	 & FR2-A: Improve generated \Gls{lua} output - Remove platform prefix & 10 & - \\
	 & FR1-E: \Gls{array} bug in text & 2 & - \\
	 & FR1-E: Pointer support (array) & 1 & - \\
	 & FR1-E: \Gls{enum} in \glspl{array} & 1 & - \\		
	 & FR6-C: \Gls{batch mode} (recursive search for subfolders) &  8  & - \\
	 & FR6-C: Support command line arguments for Cpp "--Include" (folders) & 1 & - \\
	\addlinespace
	\textbf{Testing} &  & \textbf{16} & \textbf{-} \\
	 & Fixing existing tests & 3 & - \\
	 & Add more tests for csjark module & 3 & - \\
	 & Add more tests for cparser module & 3 & - \\
	 & Add more tests for the config module & 2 & - \\
	 & Add more tests for the dissector module & 2 & - \\
	 & Add more tests for platform module & 1 & - \\
	 & Add sprint 4 end-to-end tasks & 2 & - \\
	\addlinespace
	\textbf{Doc.} &  & \textbf{10} & \textbf{-} \\
	\hyperref[tab:req:stories10]{US45} & Update command line interface document & 1 & - \\
	\hyperref[tab:req:stories11]{US49} & Update user documentation for custom \Gls{lua} & 1 & - \\
	\hyperref[tab:req:stories12]{US51} & Update user documentation for message ID & 1 & - \\
	\hyperref[tab:req:stories12]{US54} & User documentation for \gls{struct} size configuration & 1 & - \\
	\hyperref[tab:req:stories12]{US56} & User documentation for generating only \gls{struct} with valid ID or dependencies & 1 & - \\
	\hyperref[tab:req:stories9]{US36} & Which platforms that the \gls{utility} supports & 2 & - \\
	\hyperref[tab:req:stories13]{US59} & How to define new platforms to support & 1 & - \\
	\hyperref[tab:req:stories9]{US37} & Create developer manual from python docstrings & 2 & - \\
	\midrule
	& Total: & 108 &  -\\
	\bottomrule
\end{tabularx}
\end{table}

\begin{table}[!htb] \small \center
\caption{Sprint 4 Timetable\label{tab:sprint4time}}
\begin{tabularx}{\textwidth}{X c c}
	\toprule
	& \multicolumn{2}{c}{Hours} \\
	\cmidrule(r){2-3}
	Description & Est. & Act. \\
	\midrule
	\textbf{Sprint planning} & \textbf{30} & \textbf{27} \\
	\addlinespace
	\textbf{Sprint 3 requirements} & \textbf{109} & \textbf{-} \\
	Implementation & 47 & - \\
	Fixes & 35 & - \\
	Testing & 16 & - \\
	User Documentation & 11 & - \\
	\addlinespace
	\textbf{Sprint review} & \textbf{20} & \textbf{-} \\
	\addlinespace
	\textbf{Sprint documentation} & \textbf{46} & \textbf{-} \\
	Sprint 3 document & 4 & - \\
	Sprint 4 document & 42 & - \\
	\addlinespace
	\textbf{Report work} & \textbf{38} & \textbf{-} \\
	Update tables with actual hours & 2 & - \\
	Abstract - improve & 2 & -\\
	Importing user documentation to report & 3 & -\\
	Introduction section & 6 & -\\
	Report read-through from a technical perspective & 6 & -\\
	Report read-through from a non-technical perspective & 6 & -\\
	Glossary refinement & 3 & -\\
	Acronym refinement & 1 & -\\
	Write about optional requirements & 4 & -\\
	References & 3 & -\\
	Requirement agreement & 2 & -\\
	\addlinespace
	\textbf{Thales presentation} & \textbf{28} & \textbf{14} \\
	\addlinespace
	\textbf{Meetings} & \textbf{63} & \textbf{-} \\
	Advisor meetings & 28 & - \\
	Customer meetings & 14 & - \\
	Stand-up meetings & 21 & - \\
	\addlinespace
	\textbf{Project management} & \textbf{17} & \textbf{-} \\
	\midrule
	Total: & 351 & - \\
	\bottomrule
\end{tabularx}
\end{table}

\subsection{User stories}
\label{sec:req:stories4}
This section lists the user stories for the fourth sprint, these are displayed in \autoref{tab:req:stories10}, \autoref{tab:req:stories11}, \autoref{tab:req:stories12} and \autoref{tab:req:stories13}.
As we are developing a very technical \gls{utility} we have written user stories with an implementation level of abstraction. 
These user stories represent how we intend to add the functionality of each requirement to the \gls{utility}.
The administrator in this context is the administrator at Thales Norway AS. 
The developer is the person that uses \Gls{wireshark} with the \gls{dissector} generated by CSjark.

\begin{table}[htbp] \footnotesize \center
\caption{User stories - Sprint 4 part 1\label{tab:req:stories10}}
\noindent\makebox[\textwidth]{%
\begin{tabularx}{1.2\textwidth}{l X}
	\toprule
	Header & Value \\
	\midrule
	ID & US41 \\
	Requirement & FR3-A modification: \gls{include} system includes \\
	What & The \gls{utility} needs to be able to support \gls{header} files that includes system dependent \glspl{header}
	even if these are not available on the platform that the \gls{utility} is used on. \\
	How & The administrator is able to specify a fake system \gls{header} file with the defines they need to make their \glspl{struct} work correctly.
	This fake \gls{header} is then used to represent the system \gls{header} in the file so it is parsed correctly by \gls{pycparser}.  \\
	Result & The administrator is now able to make the \gls{utility} generate system dependent \glspl{dissector} for \glspl{header} with system dependent includes. \\
	\midrule
	ID & US42 \\
	Requirement & FR3-D: Ignoring \#pragma directives  \\
	What &  The \gls{utility} needs to be able to support \gls{header} files with the \#pragma directive without necessarily having to support the functionality of the directive\\
	How & Before feeding the \gls{header} files to the \gls{parser} the \gls{utility} needs to be able to run a pass through all of the \glspl{header} that are to be parsed and remove all of the \#pragma directives encountered in those \gls{header} files.\\
	Result & The user will be able to create \glspl{dissector} for \gls{header} files with the \#pragma directive instead of having the \gls{utility} be forced to skip them. \\
	\midrule
	ID & US43 \\
	Requirement & FR3-E: Find missing includes  \\
	What & It should be possible to generate \gls{dissector} from \gls{header}-files, that have definitions in \gls{header}-files that are not included with a \gls{preprocessor} directive in the \gls{header}-file.  \\
	How & The cparser module has to be able to detect when an exception is raised in the \gls{pycparser} \gls{library}, if an exception is raised, cparser has to search through the \gls{header}-files
	to find the declaration that the \gls{pycparser} \gls{library} failed on, and include this \gls{header} file. The cparser module will have to do this procedure until the \gls{dissector} is correctly parsed in the \gls{pycparser} \gls{library}. \\
	Result & The \gls{utility} shall be able to generate \glspl{dissector} for these \gls{header}-files \\	
	\midrule
	ID & US44 \\
	Requirement & Support \Gls{c} \glspl{define} from \gls{cli}  \\
	What & The administrator wants to pass \Gls{c} \gls{define} directives from the command-line to the \gls{preprocessor}.   \\
	How & When CSjark is executed, it takes the arguments given in the command-line interface and store them in the config module.
	The \gls{define} directives must be added to the \gls{preprocessor} arguments before the \gls{header}-file is parsed in the \gls{pycparser} \gls{library}.   \\
	Result & The \gls{utility} supports \Gls{c} \gls{define} directives passed from the \gls{cli}. \\
	\midrule
	ID & US45 \\
	User doc & Support \Gls{c} \glspl{define} from \gls{cli} \\
	What & The user wants to understand how the \gls{utility} will handle \Gls{c} \glspl{define} and what \glspl{define} that are possible to pass to the \gls{cli}.   \\
	How & The user finds the correct section in the user documentation, describing the command-line interface and how \Gls{c} \glspl{define} are handled.  \\
	Result & The user understands how to use \Gls{c} \glspl{define} with the \gls{utility}. \\
	\bottomrule
\end{tabularx}}
\end{table}

\begin{table}[htbp] \footnotesize \center
\caption{User stories - Sprint 4 part 2\label{tab:req:stories11}}
\noindent\makebox[\textwidth]{%
\begin{tabularx}{1.2\textwidth}{l X}
	\toprule
	Header & Value \\
	\midrule
	ID & US46 \\
	Requirement & FR7-A: Use Doxygen comments for "Description"  \\
	What & The \gls{utility} will read Doxygen comments for a \gls{struct} and use that to specify the description field for the proto object in the \gls{dissector}. \\
	How & The \gls{utility} will search the \gls{header} files for Doxygen comments before giving the file to the \gls{preprocessor}. It will note what \gls{struct} the comment
	corresponds to and add it to the config module. The \gls{dissector} module will look up in the config module for each \gls{struct} and use the description field there if it has been found.  \\
	Result & The \glspl{dissector} now requires less manual configuration because it is able to use some of the text from the \gls{header} files. \\
	\midrule
	ID & US47 \\
	Requirement & FR7-B: Read \gls{int}-\gls{enum} config from \gls{header} files \\
	What &  The \gls{utility} will read \gls{define} statements that define the allowed values and the names corresponding to those values for integers that are to be treated like enums, so that the user will not have to configure them manually.\\
	How & The \gls{utility} will search the \gls{header} files for define statements that correpsonds to a \gls{member} that is configured to be handled as an \gls{enum}. The statements needs to follow some configurable format.
	These statements are then used to auto generate a configuration file for the \gls{int} \gls{member} used to make an \gls{enum} field for the \gls{int} \gls{member} when parsing the \gls{header} file.\\
	Result & The \gls{utility} now requires less manual configurations to make \glspl{dissector} interpret certain \glspl{integer} as \glspl{enum}. \\
	\midrule
	ID & US48 \\
	Requirement & Fetch offset in custom \Gls{lua} configuration  \\
	What & The administrator should be able to add configuration in the conformance file, so it is possible to add custom \Gls{lua} code with correct offset values.  \\
	How & The conformance file must support a variable for offset, and a way to use this. The config module have to read this variable, so it can be used in the \gls{dissector} module to generate a field in the \gls{dissector} that uses the correct offset. \\
	Result & The \Gls{lua} \gls{dissector} is generated with correct offset for the custom \Gls{lua} code. \\	
	\midrule
	ID & US49 \\
	User doc & Fetch offset in custom \Gls{lua} configuration  \\
	What & The administrator shall learn how to use offset values in custom \Gls{lua} configuration.   \\
	How & The administrator reads the section in the user documentation, about how to use custom \Gls{lua} in the \gls{utility}.  \\
	Result & The user will understand how to add offset values in the conformance file. \\
	\midrule
	ID & US50 \\
	Requirement & FR4-D modification: Support multiple message ID's for one \gls{struct} \\
	What & The administrator should be able to configure more than one message ID per \gls{struct}. Therefore it is possible to use the \gls{dissector} with several different messages (specified by different ID’s).    \\
	How & The configuration file must support definition of multiple ID’s. These ID’s then have to be used for registering multiple \glspl{protocol} for one \gls{dissector}.  \\
	Result & The \Gls{lua} \gls{dissector} can be used with multiple messages with different ID’s. \\
	\bottomrule
\end{tabularx}}
\end{table}

\begin{table}[htbp] \footnotesize \center
\caption{User stories - Sprint 4 part 3\label{tab:req:stories12}}
\noindent\makebox[\textwidth]{%
\begin{tabularx}{1.2\textwidth}{l X}
	\toprule
	Header & Value \\
	\midrule
	ID & US51 \\
	User doc & FR4-D modification: Support multiple message ID's for one \gls{struct}  \\
	What & The administrator should be able to find out how to specify multiple message ID’s for a specific \gls{struct}.
	This include the proper position and syntax of the message ID’s specification. Also, he should be aware of the consequences of that definition. \\
	How & The administrator reads the configuration section in the user documentation, about how to specify multiple message ID’s for a specific \gls{struct}.  \\
	Result & The administrator is able to specify and use multiple message ID’s for a specific \gls{struct}. \\
	\midrule
	ID & US52 \\
	Requirement & FR4-I: Allow configuration to specify the size of unknown \gls{struct} \glspl{member} \\
	What & The administrator should be able specify in the configuration, how big (in bytes) the \gls{struct} \gls{member} is without having the \gls{member} itself defined. Note: This is also a workaround for \glspl{struct} that are not parseable.\\
	How & The configuration should contain an optional attribute for each \gls{struct} \gls{member} which specifies the size of the \gls{member}. If this \gls{member} is a nested \gls{struct}, and this \gls{struct} is not defined, the size has to be specified. Otherwise the user should be informed about that.\\
	Result & The \Gls{lua} \gls{dissector} can be used with \Gls{c} \gls{header} that includes unspecified \gls{struct} \gls{member}. This \gls{member} was only defined by its size, so it could be displayed as raw data in \Gls{wireshark}. \\
	\midrule
	ID & US53 \\
	User doc & FR4-I: Allow configuration to specify the size of unknown \gls{struct} \glspl{member}  \\
	What & The administrator should be able to find out how to specify in the configuration, how big (in bytes) the \gls{struct} \gls{member} is without having the \gls{member} itself defined.  \\
	How & The administrator reads the configuration section in the user documentation, about how to specify the size of the \gls{struct} \glspl{member}. \\
	Result & The user is able to specify the size of unknown \gls{struct} \gls{member}. \\	
	\midrule
	ID & US54 \\
	User doc & Auto generate configuration files for \glspl{struct} with no corresponding configuration file \\
	What & The \gls{utility} will generate template configuration files if it encounters \glspl{struct} with no corresponding configuration file. This is to make it easier to make such a configuration file.   \\
	How & The cparser module checks if an encountered \gls{struct} has a corresponding configuration in the config module. If not, the \gls{utility} writes a template file for this \gls{struct}.   \\
	Result & The user will now be able to use the auto generated template file to write the configuration for a \gls{struct} instead of having to start from scratch. \\
	\midrule
	ID & US55 \\
	Requirement & Only generate \glspl{dissector} for \glspl{struct} that have a valid ID and their dependencies \\
	What & The \gls{utility} should only generate \glspl{dissector} for \glspl{struct} that have a configuration file with a valid ID and their dependencies.    \\
	How & When the \gls{utility} discovers a \gls{struct} definition inside a \gls{header} file it should check if there exists a configuration file for that \gls{struct} and if it has a valid ID.
	If not then the \gls{utility} should skip that \gls{struct} and continue with the \gls{header} file. If a \gls{struct} with a valid configuration file and ID has a \gls{member} that is not defined in the current \gls{header}
	file, then the \gls{utility} will check the includes in the current \gls{header} for the missing \glspl{struct} and create a \gls{dissector} for them as well.\\
	Result & The \gls{utility} will not generate \glspl{dissector} for \glspl{struct} which have not been specified in the configuration.
	This gives the users of the system the ability to specify which \glspl{struct} they want to look at as well as shortening the time the \gls{utility} needs to run. \\
	\bottomrule
\end{tabularx}}
\end{table}

\begin{table}[htbp] \footnotesize \center
\caption{User stories - Sprint 4 part 4\label{tab:req:stories13}}
\noindent\makebox[\textwidth]{%
\begin{tabularx}{1.2\textwidth}{l X}
	\toprule
	Header & Value \\
	\midrule
	ID & US56 \\
	User doc & Only generate \glspl{dissector} for \glspl{struct} that have a valid ID and their dependencies  \\
	What & The administrator should be able to specify in the configuration which \glspl{struct} should have \glspl{dissector} created for them. \\
	How & The administrator reads the configuration section in the \gls{utility}’s user documentation that specifies how to specify which \glspl{struct} should have a \gls{dissector} generated for them.  \\
	Result & The user will be able to specify which \glspl{struct} the \gls{utility} will generate \glspl{dissector} for. \\
	\midrule
	ID & US57 \\
	Requirement & Guess \gls{dissector} by \gls{packet} size \\
	What & The \gls{utility} should be able to generate a \Gls{lua} file that runs with \Gls{wireshark} and guesses the \gls{dissector} that is to be used for a \gls{packet}, if it has a message ID that does not match any pre-existing \gls{dissector}.\\
	How & The luastructs.lua file that is generated by the \gls{utility} should contain a dictonary of all \glspl{dissector}, sorted by the size of the \glspl{struct} that they are associated with.
 	When a \gls{packet} with an unrecognized message ID is discovered by \Gls{wireshark}, the code in the luastructs.\Gls{lua} file should try to match the unidentified \gls{packet} with a \gls{dissector}
 	that has been generated with the same size as the unidentified \gls{packet}. The matching \glspl{dissector} should then be run with the unidentified \gls{packet}. \\
	Result & Instead of only displaying the raw hex data from the unidientified \gls{packet}, \Gls{wireshark} should display the \gls{packet} as containing all of the possible \glspl{struct} and \gls{member} values the \gls{packet} might really be containing, as dictated by the matching \glspl{dissector}. 
	This \gls{packet} should also be displayed with a warning. \\
	\midrule
	ID & US58 \\
	Requirement & Display if \gls{struct} \gls{member} contains uninitialized memory \\
	What & The \glspl{dissector} generated by the \gls{utility} should be able to identify \gls{struct} \glspl{member} that might possibly have uninitialized memory set as their values.
 	These \glspl{member} and their values should be displayed with a warning in \Gls{wireshark} to indicate that the values might have been uninitialized.  \\
	How & If the \Gls{c}-code that uses \gls{header} files isn’t using memset to set the initial values of different variables a \gls{parser} might decide to fill uninitialized variables with some kind of patterned garbage data.
 	This pattern might be possible to detect by the \glspl{dissector} generated by the \gls{utility} by adding a check to the \gls{dissector} code which compares the \gls{member} values with different known garbage-patterns generated by different \glspl{parser}. \\
	Result & The \gls{utility} will now be able to generate \glspl{dissector} which will make \Gls{wireshark} display \gls{struct} \glspl{member} and their values with a warning if they are suspected as being filled with uninitialized memory. \\	
	\midrule
	ID & US59 \\
	User doc & How to define new platforms \\
	What & The Administrator should be able to define new platforms to support.  \\
	How & The user should look in the user documentation, and read the section about defining new platforms. \\
	Result & After the administrator has defined the new platform, the \gls{utility} should be able to generate \glspl{dissector} for the new platform. \\	
	\bottomrule
\end{tabularx}}
\end{table}

%----------------------
\section{System Design}
%----------------------
\label{sec:sp4design}
The utility lacked the last, but also most essential implementation at the start of fourth sprint; ability to run customer's source code flawless. 
The sprint design this sprint will not be as comprehensive as the design in the prior sprints. This is because of two reasons:
\begin{itemize}
	\item This is the last sprint, if we are to implement many new features we must also have time to test and write documentation for them, which we do not have.
	\item The existing features have to be extensively tested and documented before the project is over, leaving little time for other work. Testing and bugfixing will usually not result in major changes in the design.
\end{itemize}

After three sprints, the design is to a large degree set. Re-factoring introduced some new modules, but it was just to make the code more logic and to distribute it so testing can be done more easily. This is described in the system overview section.


\subsection{System overview}
%-----------------------


%class diagram
The addition of new requirements made a re-factoring necessary:
\begin{itemize}
\item The need for custom handling of \Gls{c} preprocessor steps on \Gls{c} header files have become so comprehensive, that we have decided to create our own module for it.
\item Field specific classes now have their own module.   
\end{itemize}  


%-----------------------
\section{Implementation}
%-----------------------
\label{sec:sp4impl}

The implementation in this sprint has mainly been bug fixing, and adding 
features that the customer needs to be able to run the \gls{utility} on their code. 
This section covers the added functionality and the most important fixes 
in this sprint.

\subsection{Include Unsupported System-\glspl{header}}
%--------------------
CSjark must be able to support both Windows and Solaris operating system. To 
be able to generate dissectors from header-files, it was necessary to add 
system specific header-files for Windows and Solaris. This is done by adding 
the system-headers to the ''fake\_libc\_include''. ''fake\_libc\_include'' is 
a fake library for standard header-files, that only contains default typedefs 
and default defines. Most of the header-files in the fake library are empty, 
so the preprocessor can find the files that are included.

\subsection{Ignore \#pragma Directives}
%--------------------
Pragma directive is a \gls{preprocessor} directive that is used to give options to 
the compiler. This can for example be used to ignore warnings or give the 
compiler version-information of the code. Since the pycparser \gls{library} do not 
support pragma directives, these lines in the \Gls{c}-code is removed before the 
preprocessing. Removing these lines will not affect the \gls{utility}, since the 
\gls{utility} never compiles the code.

\subsection{Include Dependencies}
%--------------------
Include dependencies was the biggest issue in this sprint. The customer 
include all their \gls{header}-files in the code file, and they only are going to 
generate \Gls{lua} \glspl{dissector} from \gls{header}-files. The reason they only will generate 
from \gls{header}-files is that some of the code is \gls{c++}, and the size of the entire 
source code is about 1GB, which would take very long time to parse for a 
\gls{utility} like CSjark. 

This problem is very difficult to solve, since the include directive is needed 
to be able to parse \gls{header}-files that depend on other \gls{header}-files. To be able 
to solve this problem, the \gls{utility} have to find the includes that the 
\gls{header}-file depends on, and include them in the correct order, because the 
included \gls{header}-files can be dependent on each other.



TODO: Not finished

\subsection{Improve Generated \Gls{lua} Output}
%--------------------
To improve the performance of the \Gls{lua} \glspl{dissector} in \Gls{wireshark}, it was 
necessary to change how the different platforms were handled in the \Gls{lua} 
\gls{dissector}. Until this sprint the \gls{utility} generated one \gls{dissector} table for 
each platform. To make the \glspl{dissector} more efficient in \Gls{wireshark}, it was 
changed to only have one \gls{dissector} table for all the \glspl{dissector}, and call 
different functions for each of the platforms. To change this the \gls{dissector} 
module in CSjark was modified to generate the \glspl{dissector} correctly. By fixing 
this issue, it was also possible to use the autocomplete feature in the 
expression field for filter and search.

\subsection{Support Subfolders in Batch Mode}
%--------------------
A bug was fixed in batch mode, the problem was that subfolders was not support 
on other system than Windows. This was fixed so it now works on all platforms.

\subsection{Fixed Proto Fields for \Glspl{array}}
%--------------------
After adding support for complex \glspl{array} in sprint 3, some bugs occured in the 
proto fields for \glspl{array}. The names for these proto fields were fixed, so it is 
possible to filter and search for values in \glspl{array}. 

\subsection{\gls{cli} Support for Include Folders}
%--------------------
Support for specifing include folders was implemented in this sprint. This is 
given as an argument to the \gls{cli} with  \emph{-I} or \emph{-Includes} followed 
by the folders to include. The folders included will be added as an argument 
to the \gls{preprocessor}, so the \gls{preprocessor} can search for files in these 
folders, when a file is given in a include directive(\gls{include}). 

\subsection{\gls{cli} Support for \Gls{c} Macro Definitions}
%--------------------
The \gls{utility} supports \Gls{c} Macro definitions as arguments from the \gls{cli}. A macro 
definition is also known as \emph{\gls{define}}. This feature was added since it 
should be possible to add macro definitions to the \gls{preprocessor}, instead of 
modifing several \gls{header}-files. During a run of the \gls{utility} with macro 
definitions specified, the definitions will be given for all the parsed 
\gls{header}-files.

\subsection{Support Multiple \gls{dissector} ID }
%--------------------
The \gls{dissector} ID for \glspl{dissector} was modified in this sprint, so that a \gls{struct} 
can have multiple \glspl{dissector}. This was done since a \gls{struct} can have multiple 
message ID's, in the system that the customer uses. After this fix it is 
possible to add a list of message ID's to the configuration file of the 
\gls{struct}, and the \Gls{lua}-\gls{dissector} will add all message ID's to the \gls{dissector} table.

\subsection{Configuration of Size for Unknown Structs}
%--------------------
\Gls{header}-files that the \gls{utility} parses, may have have nested \gls{struct} that is not 
defined in any other \gls{header} file. To make the it possible to generate a 
\gls{dissector} for this case, it must be possible to specify the size of the \gls{struct} 
in a configuration file. When the sizes are specified it will be possible to 
generate a \gls{struct} that can display the defined \glspl{member} of the \gls{struct} correctly 
in the \gls{utility}, for the parts that are not defined only the hex value will be 
displayed. 

This feature is added as a possible way to solve include dependencies that our 
\gls{utility} is not able to solve. The user of the \gls{utility} will get an error 
message when the \gls{utility} is not able to find the include dependencies, and the 
user may add the size of \gls{struct} to be able to generate a \gls{dissector} for \gls{struct}. 
An example of configuration of size for a \gls{struct}, is shown in 
\autoref{code:configsize}

\lstset{language=C,caption={Configuration of struct size},label=code:configsize}
\lstinputlisting[language=C]{./sprints/code/configsize.yml}

\subsection{Support Offset and Value in Custom \Gls{lua} Files}
%--------------------
After feedback from the customer it was needed to add some more features to 
the handling of custom \Gls{lua} files. This feature was that it should be possible 
to add new proto fields to the \gls{dissector} \Gls{wireshark}, with correct offset value 
and correct \Gls{lua} variable. To be able to do this, it was necessary to add a 
variables for offset and value in the conformance file. Use of the \Gls{lua} 
variable and offset value is only possible in the functionality part of the 
\Gls{lua} \gls{dissector}. \autoref{code:customcnfsp4} is an example of how value and 
offset can be used, and \autoref{code:customluasp4} shows the result in the \Gls{lua} 
\gls{dissector}.

\lstset{language=C,caption={Custom Lua: offset and value},label=code:customcnfsp4}
\lstinputlisting[language=C]{./sprints/code/customsp4.cnf}

\lstset{language=C,caption={Custom Lua: Lua code for value and offset},label=code:customluasp4}
\lstinputlisting[language=C]{./sprints/code/customsp4.lua}

\subsection{Support Array of Pointers}
%--------------------
A pointer is a variable that contains the memory address for a variable. 
Support for arrays of pointers was added so the array can be correctly 
displayed in \Gls{wireshark}, with correct sizes for different platforms.

Remove this subsection if it is not implemented

\subsection{Autogenerate Configuration Files}
%--------------------
The autogeneration of configuration file is a simple feature, that could save 
the user of the \gls{utility} some time, since the essential part of the 
configuration file is generated automatically. The \gls{utility} will only create a new 
file, containg the name of the \gls{struct} and line to specifiy the ID for the 
\gls{dissector}. To generate the configuration file, the \gls{utility} must be run with 
\emph{-p} or \emph{--placeholders} as an option. 

\subsection{Only Generate \glspl{dissector} for Structs with Valid ID}
%--------------------
Since sprint 2 the \gls{utility} has been generating \glspl{dissector} for all \gls{header}-files 
found in a folder, when running in \gls{batch mode}. This has been fixed, so the \gls{utility} 
only generates \glspl{dissector} for \glspl{struct} that have a configuration file with an 
ID, and for \glspl{struct} that depend on other \glspl{struct}. This will speed up the 
generation of \glspl{dissector}, since it only generates \glspl{dissector} that \Gls{wireshark} 
can use.

\subsection{Guess \gls{dissector} From Packet Size}
%--------------------

TODO: 

\subsection{\gls{cli} Support to Exclude Files or Folders}
%--------------------
TODO

%-----------------------
\section{Sprint Testing}
%-----------------------
\label{sec:sp4test}

%--------------------------
\section{Customer Feedback}
%--------------------------
\label{sec:sp4feedback}

%--------------------------
\section{Sprint Evaluation}
%--------------------------
\label{sec:sp4eval}

