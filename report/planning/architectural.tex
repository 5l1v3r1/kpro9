%==================================
\chapter{Architectural Description}
%==================================
This chapter introduces the architectural documents pertaining to our solution. The team followed the definition of software architecture defined by Len Bass, Paul Clements and Rick Kazman: "The software architecture of a program or computing
system is the structure of structures of the system, which comprise software elements, the externally visible properties of those elements, and the relationships between them."

The purpose of this document is to describe our architecture in a structured way so that it can be used not only by the team, but also as an aid for other stakeholders who are trying to understand the system.

\section{Architectural Drivers}
%------------------------------
This section is dedicated to the discussion of the architectural drivers
The team has chosen Modifiability and Testability as the quality attributes for this utility. 

The reason for using Modifiability is that the development team are not going to be the ones updating or maintaining the utility after the completing the project. It is therefore important that the code is easy to understand, good documented and easy to modify. This will make it easier for our customer to later modifiy or extend the utility.

Testability is important since the utility will be used for debugging by the customer.  Since it is not possible for the team to test the dissectors in a real enviorment, it will be more important to focus on testing. This to ensure that the final product is working correctly.

\subsection{Testability Tactics}
The goal of using testability tactics is making it easier to test the system after finishing an increment of the software development. 

\subsubsection{Specialize access routes/interfaces}
Using a specialized testing interface makes it possible to specify values for a component independently from its normal execution. This will in turn make it possible to test parts of an unfinished module as well as making it easier to get a clear overview over what data is flowing through individual parts of the system.

\subsection{Modifiability Tactics}
The goal of using modifiability tactics are to make it easier to extend and modify the software during the development and after having made a working product.

\subsubsection{Anticipate Expected Changes}
By trying to anticipate expected changes it is possible to make it easier for modules to be extended with new functionality later. It also makes it easier for the developers to anticipate the different ranges of input the modules are about be able to process.

\subsubsection{Limit Possible Options}
By limiting the range of possible modifications to the system it becomes easier to generalize the structure of different modules. This will in turn make it easier to constrict the wide ranging effect of new modifications to the system, giving the developers a clearer view over what a given change will actually do to the system.

\subsubsection{Generalizing Modules}
Generalizing the modules of a system makes it possible to reuse older modules when doing modifications to the system. The more general a module, the more likely it is that a needed change to the system can be implemented just by adjusting the input to the system rather than having to modify existing or creating new modules.

\subsubsection{Restrict Communication Paths}
By restricting the number of modules that are able to collect data from a specific module, the less dependent the entire system becomes of that specific module. This makes it easier to swap out existing modules with new ones without having to make many widespread changes to the entire system.

\subsubsection{Using Configuration Files}
By using configuration files, it is possible to change the behaviour of the system without having to do any changes to its code.

\subsection{Business Requirements}

\begin{itemize}
\item The utility must be delivered on time as it is not possible for the developers to continue the development after the deadline
\item The ability for the utility to be able to create dissectors for c-structs in header files used by Thales
\item The ability for the utility to create dissectors that run on all of the platforms used by Thales and their customers
\item The ability for wireshark to be able to use the generated dissectors do display the values in c-structs passed through the system.
\end{itemize}


\section{Architectural Patters}
%------------------------------
This section presents the different architectural patterns used in the utility
\subsection{Pipe and Filter}
The pipe and filter architectural pattern consists of a stream of data which is in turn processed sequentially by several filters in such a fashion that the output of one filter becomes the input of the other. It is a very flexible yet robust way of processing data, with support for adding more filters if needed for future applications and processes.
\begin{figure}[ht]
\includegraphics[width = \textwidth]{./planning/img/PipeAndFilter}
\caption{Pipe and Filter Pattern} 
\label{fig:pipefilter}
\end{figure}

\section{Architectural Views}

\subsection{Logical View}
This view shown in \autoref{fig:logicalview}. Command line takes the arguments for header file and configuration file as a string. The arguments are parsed in the command line parser. Header file is sent to ''C preprocessor \& C parser", the c header file is loaded and parsed by the c parser, and generate a parsing tree. Command line also call Configuration, which load the configuration file. The configuration will parse the configuration file and create configuation rules. The Lua script generator will generate a Lua script from the parseing tree and the config rules.

\begin{figure}[ht]
\includegraphics[width=\textwidth]{./planning/img/overall_design.png}
\caption{Overall Architecture}
\label{fig:logicalview}
\end{figure}

\section{Process View}
\autoref{fig:processview} shows the process view for our utility. Csjark takes header and config files as input and then uses the config and cparser to parse the files. CSjark then uses the cparser to find the structs in the header file and then creates dissectors for them. These dissectors are then written to a file and CSjark then reports to the user by sending a message to the command line.

\begin{figure}[ht]
\includegraphics[width=\textwidth]{./planning/img/SequenceDiagram.png}
\caption{Data flow during regular execution}
\label{fig:processview}

\section{Deployment View}
\autoref{fig:deployment} shows the deployment diagram for this project. Csjark takes header- and config-files as input, and generates Lua-scripts. The Lua-scripts are used for dissectors in Wireshark.

\begin{figure}[ht]
\includegraphics[width = \textwidth]{./planning/img/Deployment}
\caption{Deployment View} 
\label{fig:deployment}
\end{figure}

\section{Architectural Rationale}
%--------------------------------
The team decided to use the pipe and filter pattern as the architects felt that it was the only architectural pattern that would benefit the utility without having to make it needlessly complex. The utility was supposed to take header files as input and then process the data from them several times until the end result was a list of structs and members that could be used to make dissectors for wireshark. This seemed like an excellent application to use the pipe and filter pattern with as it would then be easy to add new filters to the header file for future increments of the development cycle so without having to rewrite what had already been implemented in previous sprints.

For the views the team decided to use a logical view, process view and deployment view. These views were chosen because the architects of the utility felt that these views alone could represent the system sufficently without creating too much overhead for the readers of the document. The logical view supplies the reader with a more in depth view of what the system is comprised of, which is useful for developers who need to figure out the workings of the system. The process view also seemed important for the developers and the testers of the utility, as it provides the reader with a more proper overview of the dataflow in the system. This makes it a lot easier to see which modules are run when and which external calls that dictates their behaviour. Lastly a deployment view was chosen to make it more clear for the reader of the document what the utility really produces as output and what other external applications it has to cooperate with. 
   

