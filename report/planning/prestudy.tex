%==========================
\chapter{Preliminary Study}
%==========================
This chapter presents the preliminary studies for this project. This includes
the technology and methodology used to develop the utility, and an evaluation
of choices we made in the beginning of the project. It also includes a
comparison to existing solution.

\section{Similar Solutions}
%--------------------------

\subsection{idl2wrs}
A tool for generating Wireshark dissectors from IDL files. The tool is written
in python, and generates dissectors in C from IDL specifications. Interface
Description Language (IDL) is used to interface in a language-neutral way,
which enables communication between software of different languages. It is
used for example in Sun RPC and CORBA. Since idl2wrs takes input in a different
language than us, and creates dissectors in a different language than us, we
can not reuse any of its code. Instead we will look at its architecture and
data structures, especially how it generates dissectors.

\subsection{asn2wrs}
This is a compiler which are used to create dissectors for wireshark for a
specified protocol. The tool uses ASN.1 to describe the protocol, and compile a
plugin for wireshark. To use the compiler, four files is need as input, an
ASN-1 protocol description, a configuration files(.cnf) and two template files.
The main reasons to use asn2wrs to create dissectors, is that it speeds up the
development, since it only is necessary to recompile the plugin, and to allow
flexibility since itâ€™s easy to distribute the plugin. Disadvantages with this
solution is that the code and makefiles are more complex. This solution is not
an alternative for our customer since the will need to rewrite their c-structs
to ASN.1 descriptions, which will take very long time, due to larges header
files and the amount of header files.
http://wiki.wireshark.org/Asn2wrs
http://wiki.wireshark.org/ASN1_plugin

\section{Software Development Methodology}
%-----------------------------------------

\subsection{Waterfall}
Waterfall is a software development methodology based on sequential phases.
These phases can be the following: requirement specification, design,
implementation, integration, testing, deployment and maintenance. In its pure
form, these phases are non overlapping and one way only, which means that each
phase must be fully completed before the next can begin. Following is a short
description of each phase:

\subsubsection{Requirement specification}
This phase is about receiving requirements from a customer and then formalising
these into concrete functional and non-functional requirements. These will
again be further broken down into smaller work items that are easy to quantify
in terms of time of use and importance. These metrics may help distinguish
which features that are to be prioritised.

\subsubsection{Design}
The design phase is about planning how to implement the features from the
requirement phase. The goal is to make a precise software architecture for the
project that dictates most of the implementation phase. This may include (but
not limited to) making class diagrams, data flow diagrams, state machines, user
interface mockups, etc.

\subsubsection{Implementation}
This phase is about implementing/coding the design made in the design phase on
a component level.

\subsubsection{Integration}
This phase is about integrating the different components that results from the
implementation phase.

\subsubsection{Testing}
The testing phase aims to thoroughly test the result of the implementation and
integration phase. The goal is to find and fix bugs introduced in both these
phases.

\subsubsection{Deployment}
The deployment phase is about delivering the resulting software to the
customer. This may include installing the software on their systems. This is
also the phase where the customer either accepts or rejects the resulting
software.

\subsubsection{Maintenance}
Large software projects are almost impossible to get completely bug free, and
therefore a certain amount of maintenance may be required. The obvious tasks
are to either fix or provide viable workarounds for problems that appear during
normal use. Maintenance may also include developing new features that the
customer finds the need for.

\subsection{Scrum}
Scrum is an agile development methodology based on the philosophy that it is
impossible to completely and accurately plan everything in a software project
before you begin. It is therefore more or less based on iterations of the
phases described under waterfall(FIX LINK), but instead of having these phases
being strictly sequential, they are run in a more 'as needed' basis. Each
iteration in scrum is called a sprint and is typically lasting from two and up
to four weeks. This time period is fixed for each project, so the sprint will
always end on time. To make this possible, features that are not completed on
time is deferred to a later sprint. Each sprint should result in a runnable
product that potentially could deliver some value to the customer, even if this
requires some redundant work.

\noindent A Scrum project has three main roles:
\begin{description}
	\item[Scrum master] has the responsibility of maintaining the process and
		for removing obstacles for other team members. In short, the scrum
		master tries to keep the other team members focused on their tasks.
	\item[Product owner] represents and speaks for the customer. Not
		necessarily a part of the customers organization, but must have the
		stated authorities.
	\item[Team members] responsible for making and delivering the product.
		Should consist of a self organizing team of five to nine persons with
		cross functional skill set.
\end{description}

\noindent There are also tree main artifacts:
\begin{description}
	\item[Product backlog] contains a high level description of all the desired
		features for the project. These should be prioritised based on their
		business value and evolve along with the project.
	\item[Sprint backlog] contains what the team is committed to complete over
		the next sprint. These commitments are features broken down into work
		items. These items should not be larger than 16 hours of work, and they
		should be described so that everyone in the team could contribute to
		implementing them.
	\item[Burn down chart] A daily updated chart consisting of what work
		remains in the sprint. Its purpose is both to show what work to do next
		and to give a visual representation of the work progress.
\end{described}

A sprint begins with the sprint planning meeting. This meeting consists of two
stages. In the first, the team and the product owner prioritizes the product
backlog. In the second. the team discusses what features they can commit to
(based on priority) and brakes these down into work items, which are added to
the sprint backlog. This should include giving each item an estimated
completion time.

The sprint itself consists of producing what is required for completing work
items, updating the burn down chart and daily scrum meetings. In these daily
meetings each team member gives the rest a short update of what they did
yesterday, what they plan to do today and what problems might be in their way.
These problems should not be discussed in this meeting, but rather dealt with
separately after the meeting (this is the scrum masters responsibility).

At the end of the sprint cycle, the team should hold a scrum review meeting.
This meeting is about discussing what was completed and what was not, and to
demonstrate the completed features for the customer.

After the review meeting, a separate retrospect meeting should be held with all
the team members where all members shares their reflection of how the sprint
went and how to improve for the next sprint. This is important for making
continues improvements to the process.

